{
  "timestamp": "2026-02-27T05:41:07.064Z",
  "projectId": "838e7498-6dc5-4268-9fcd-e6f6148f65ad",
  "scenario": "restock-badge-lengths",
  "prompt": "Add available lengths text under the \"Awaiting Restock\" badge when a color is out of stock in the currently selected length but available in other lengths. Show which non-color options are still available for that color.",
  "totalRuns": 1,
  "results": [
    {
      "run": 1,
      "passed": false,
      "reason": "Missing required file edits: assets/product-form-dynamic.css",
      "metrics": {
        "totalToolCalls": 19,
        "editToolCalls": 6,
        "readToolCalls": 10,
        "searchToolCalls": 1,
        "elapsedMs": 142775,
        "costCents": 45,
        "inputTokens": 125897,
        "outputTokens": 4239
      },
      "tier": "COMPLEX",
      "strategy": "GOD_MODE",
      "changedFiles": [
        "assets/product-form-dynamic.js",
        "snippets/product-form-dynamic.liquid",
        "product-form-dynamic.js"
      ],
      "transcript": {
        "runId": "run-1",
        "scenario": "restock-badge-lengths",
        "decisions": [
          {
            "phase": "analyzing",
            "label": "Loading context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Context ready",
            "detail": "606 files, 5 prefs",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Classifying request...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Preparing file context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building structural brief...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Starting agent...",
            "timestamp": 0
          },
          {
            "phase": "strategy",
            "label": "Strategy: GOD_MODE",
            "detail": "strategy=GOD_MODE, tier=COMPLEX",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "COMPLEX tier — GOD_MODE strategy — claude-sonnet-4-6",
            "detail": "routingTier=COMPLEX, strategy=GOD_MODE",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Style profile loaded",
            "detail": "styleProfileRules=8, designTokenCount=0, patternConflictResolutions=0, referenceSectionsLoaded=0, cssPreloaded=false, snippetConsumers=0",
            "timestamp": 0
          }
        ],
        "toolSequence": [
          {
            "name": "read_lines",
            "id": "toolu_01HNA8RjY7TdoPA8JapSdeqM",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 690,
                  "endLine": 820
                },
                {
                  "startLine": 860,
                  "endLine": 900
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01TUHKSX6XhJwQaFGdkErT6e",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 600,
                  "endLine": 690
                },
                {
                  "startLine": 1,
                  "endLine": 50
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_018ZksG6LMUUhJEeGp5jB4UV",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 400,
                  "endLine": 440
                },
                {
                  "startLine": 900,
                  "endLine": 980
                },
                {
                  "startLine": 1450,
                  "endLine": 1620
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01NULGu4UrhkcBAg1CJV1j6w",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 442,
                  "endLine": 530
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01QJ7T7gRKdTggzJY93rX73C",
            "input": {
              "filePath": "snippets/product-form-dynamic.liquid",
              "ranges": [
                {
                  "startLine": 100,
                  "endLine": 160
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01TFh6z6HoAWH7K7u4iZjjD4",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 703,
                  "endLine": 799
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_017nax9PmmqrTKrRvbqF1ETH",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 810,
                  "endLine": 830
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_0124FTViHDQSPRjmuptcMHfD",
            "input": {
              "fileName": "assets/product-form-dynamic.js"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01PzgaXFnjhfuxokCUWczK1n",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 820,
                  "endLine": 835
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_019R4bxa7CzxnTyTZUzZsb2e",
            "input": {
              "fileName": "assets/product-form-dynamic.js"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01BEuvLuAadEK7hPv1yPGXqe",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 703,
                  "endLine": 830
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "semantic_search",
            "id": "toolu_01RQscTL8EFqXbFLTb1ca6GH",
            "input": {
              "query": "__LENGTH_OPTION_INDEX__ initialization set window",
              "limit": 5
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "extract_region",
            "id": "toolu_01Lawx8mcqWZAtoNQDBjAF5d",
            "input": {
              "fileId": "snippets/product-form-dynamic.liquid",
              "hint": "__LENGTH_OPTION_INDEX__"
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772170754209",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Generalize updateAvailableLengths to work with any non-color option, not just the hardcoded LENGTH_OPTION_INDEX. This makes it show available values for all non-color options when a color swatch is out of stock at the current selection."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01BFwBkLEyaX7NDH2WNcx9MA",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 703,
              "endLine": 799,
              "newContent": "function updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl.classList.remove(\"is-visible\");\n  }\n}",
              "reasoning": "Generalize updateAvailableLengths to work with any non-color option, not just the hardcoded LENGTH_OPTION_INDEX. This makes it show available values for all non-color options when a color swatch is out of stock at the current selection."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772170761605",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Fix the malformed else-if clause — was missing the condition check and had a syntax error."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01U2MFzd1zqDjcJEYZxLu7tU",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 825,
              "endLine": 826,
              "newContent": "  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}",
              "reasoning": "Fix the malformed else-if clause — was missing the condition check and had a syntax error."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772170769989",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Remove the extra closing brace left over from the previous edit."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_0186zvDE6aEsQar3yDMyPfbu",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 829,
              "endLine": 829,
              "newContent": "",
              "reasoning": "Remove the extra closing brace left over from the previous edit."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          }
        ],
        "reasoningBlocks": [],
        "responseText": "",
        "outcome": {
          "status": "applied",
          "changedFiles": 3,
          "changeSummary": "product-form-dynamic.js: Generalize updateAvailableLengths to work with any non-color option, not just the hardcoded LENGTH_OPTION_INDEX. This makes it show available values for all non-color options when a color swatch is out of stock at the current selection.",
          "validationIssues": [
            {
              "gate": "syntax",
              "errors": [
                "templates/page.ecom-deadfest2025.json:0 — Invalid JSON in template file",
                "templates/article.portfolio.json:0 — Invalid JSON in template file",
                "templates/page.ecom-deaducation-live-phoenix.json:0 — Invalid JSON in template file",
                "templates/index.ecom-preview-home.json:0 — Invalid JSON in template file",
                "templates/index.ecom-preview-page.json:0 — Invalid JSON in template file"
              ],
              "changesKept": true
            },
            {
              "gate": "theme_check",
              "errors": [
                "templates/page.ecom-deadfest2025.json — Invalid JSON in template file",
                "templates/article.portfolio.json — Invalid JSON in template file",
                "templates/page.ecom-deaducation-live-phoenix.json — Invalid JSON in template file",
                "templates/index.ecom-preview-home.json — Invalid JSON in template file",
                "templates/index.ecom-preview-page.json — Invalid JSON in template file"
              ],
              "changesKept": true
            }
          ]
        },
        "metrics": {
          "totalToolCalls": 19,
          "editToolCalls": 6,
          "readToolCalls": 10,
          "searchToolCalls": 1,
          "elapsedMs": 142775,
          "costCents": 45,
          "inputTokens": 125897,
          "outputTokens": 4239
        }
      },
      "analysis": {
        "diagnosis": {
          "summary": "Agent successfully identified the requirement and made 3 file changes, but the tool sequence shows 8 ERROR responses (tools 12-19) that were silently swallowed. The agent appears to have recovered and completed the task despite these failures, but the error handling masked potential issues. The final state shows the changes were applied, but the error cascade suggests tool executor or coordinator validation gates failed to properly surface or handle tool execution failures.",
          "rootCause": "Tool executor (lib/agents/tools/v2-tool-executor.ts) returned errors for semantic_search, extract_region, and multiple propose_code_edit/edit_lines calls without proper error propagation or retry logic. The coordinator (lib/agents/coordinator-v2.ts) did not escalate these failures or trigger validation gates. The agent continued iterating despite tool failures, suggesting either: (1) error responses were treated as valid 'no result' rather than failures, or (2) the coordinator's stagnation detection did not trigger on repeated tool errors.",
          "agentBehavior": "Agent executed 19 tool calls in GOD_MODE strategy. Tools 1-11 succeeded (read_lines, check_lint). Tools 12-19 all returned ERROR with '[ERROR] -> (no result received)' but agent continued. Despite errors, the transcript shows '3 files changed' were applied, indicating either: (a) the errors occurred during refinement/validation phases after successful edits, or (b) the tool executor caught errors internally and the coordinator proceeded. The agent did not attempt recovery, fallback strategies, or explicit error handling—it simply moved past failures."
        },
        "recommendations": [
          {
            "priority": "critical",
            "category": "tools",
            "title": "Tool executor error response handling is opaque",
            "description": "semantic_search, extract_region, and propose_code_edit tools returned ERROR with no error details. The tool executor should distinguish between 'no result found' (valid) and 'tool execution failed' (error state). Currently, errors are logged as '[ERROR] -> (no result received)' which conflates tool failure with empty results.",
            "targetFile": "lib/agents/tools/v2-tool-executor.ts",
            "targetArea": "run_specialist, run_review execution and error handling blocks",
            "suggestedChange": "Add explicit error classification: (1) Catch and log tool errors with stack traces, (2) Return structured response with { success: boolean, error?: string, result?: any }, (3) Differentiate 'no match' from 'execution failed' in coordinator logic. Example: if (toolResponse.error && toolResponse.error.includes('malformed')) { escalate to coordinator validation gate } else if (!toolResponse.result) { continue normally }"
          },
          {
            "priority": "critical",
            "category": "coordinator",
            "title": "Coordinator does not escalate or handle tool execution failures",
            "description": "Tools 12-19 all failed but agent continued iterating without triggering stagnation detection, validation gates, or fallback strategies. The coordinator's iteration loop (think -> tool -> observe -> repeat) does not check tool response status or error fields. Repeated tool failures should trigger escalation or strategy downgrade.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Main iteration loop, tool result observation and validation gates",
            "suggestedChange": "After tool execution, add validation gate: (1) Check if tool response contains error field, (2) If error count > 2 in last 5 iterations, trigger stagnation detection, (3) If semantic_search or extract_region fails 2x consecutively, downgrade strategy from GOD_MODE to HYBRID or SIMPLE, (4) Log failure reason to context for next iteration. Pseudocode: if (toolResult.error) { failureCount++; if (failureCount >= 2) { strategy = downgradeStrategy(strategy); context.addWarning('Tool failures detected, reducing complexity'); } }"
          },
          {
            "priority": "high",
            "category": "validation",
            "title": "Orchestration policy does not validate tool pre-conditions",
            "description": "Tools like semantic_search and extract_region failed silently. These tools require specific file/context state. The orchestration policy should validate preconditions (file exists, file is indexed, query is well-formed) before tool execution, not after.",
            "targetFile": "lib/agents/orchestration-policy.ts",
            "targetArea": "Context gates and tool precondition validation",
            "suggestedChange": "Add pre-tool validation gates: (1) semantic_search: verify theme map is loaded and query length > 3, (2) extract_region: verify file exists in theme map and hint is non-empty, (3) propose_code_edit: verify file is writable and edit range is valid, (4) If precondition fails, return early with informative error instead of attempting tool call. Example: if (!themeMap.hasFile(fileId)) { return { error: 'FILE_NOT_INDEXED', suggestion: 'Use read_lines instead' }; }"
          },
          {
            "priority": "high",
            "category": "prompt",
            "title": "PM prompt does not instruct error recovery or fallback strategies",
            "description": "When tools fail (e.g., semantic_search returns no results), the agent should have explicit instructions to fall back to read_lines + grep_content or adjust query. The v2-pm-prompt does not provide error recovery guidance, leaving agent to continue blindly.",
            "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
            "targetArea": "Tool usage instructions section",
            "suggestedChange": "Add error recovery section to system prompt: 'If semantic_search fails or returns no results, use grep_content with simpler keywords. If extract_region fails, use read_lines with estimated line ranges. If propose_code_edit returns error, validate syntax first with check_lint. Always attempt at least one fallback before escalating.' Include specific examples of fallback chains."
          },
          {
            "priority": "high",
            "category": "context",
            "title": "Theme map caching may have stale or incomplete index",
            "description": "Tools 12-13 (semantic_search, extract_region) failed, suggesting theme map lookup returned no results or file was not indexed. The scout brief and theme map cache may not have indexed all necessary files or line ranges for this complex multi-file change.",
            "targetFile": "lib/agents/theme-map/cache.ts",
            "targetArea": "Cache invalidation and line range tracking",
            "suggestedChange": "Verify cache warmup: (1) Ensure all files identified by scout (product-form-dynamic.js, product-form-dynamic.liquid, etc.) are in cache before coordinator starts, (2) Track line ranges for functions like updateAvailableLengths, (3) Add cache hit/miss logging. If semantic_search fails, log which files were indexed and which queries were attempted. Consider pre-indexing common Shopify patterns (option swatches, availability logic) at startup."
          },
          {
            "priority": "medium",
            "category": "coordinator",
            "title": "Iteration count and stagnation detection not visible in transcript",
            "description": "Transcript shows 19 tool calls but does not indicate how many iterations were used, whether max 80 iterations was approached, or if stagnation detection triggered. Without visibility, it's unclear if the agent recovered from errors naturally or if it simply gave up and returned partial results.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Iteration tracking and logging",
            "suggestedChange": "Add iteration-level logging: Log '[iteration N/80] strategy=GOD_MODE, tool_failures=M, context_tokens=K' after each think-tool-observe cycle. Include stagnation detection threshold (e.g., 'Stagnation triggered: 3 identical observations in last 4 iterations'). This makes failure modes visible and helps diagnose recovery vs. abandonment."
          },
          {
            "priority": "medium",
            "category": "tools",
            "title": "propose_code_edit tool may have malformed input or response",
            "description": "Tools 14, 16, 18 (propose_code_edit) all returned ERROR. The agent reasoning mentions 'Fix the malformed else-if clause' but propose_code_edit errors suggest the tool itself rejected the request. Tool may require specific fields (e.g., lineStart, lineEnd) that were missing.",
            "targetFile": "lib/agents/tools/v2-tool-definitions.ts",
            "targetArea": "propose_code_edit schema and required fields",
            "suggestedChange": "Review propose_code_edit schema: (1) Ensure all required fields are documented (filePath, newContent, reasoning, lineStart?, lineEnd?), (2) Add validation error messages that explain which fields are missing, (3) Consider if tool should be split into two: propose_code_edit (planning) and apply_code_edit (execution), to separate analysis from mutation."
          },
          {
            "priority": "medium",
            "category": "strategy",
            "title": "GOD_MODE strategy may be too aggressive for file-mutation heavy tasks",
            "description": "Agent selected GOD_MODE (COMPLEX tier) and made 6 edits with 10 read calls. However, repeated tool failures (tools 12-19) suggest the agent was over-confident and attempted advanced tools (semantic_search, extract_region) that failed. HYBRID or SIMPLE strategy might have used more reliable tools (read_lines, grep_content, check_lint).",
            "targetFile": "lib/agents/strategy.ts",
            "targetArea": "Strategy selection logic for COMPLEX tier",
            "suggestedChange": "Add heuristic: If request involves multiple file edits (>3) and file structure is not well-understood, prefer HYBRID over GOD_MODE. Pseudocode: if (estimatedFileCount > 3 && !themeMap.isFamiliar(files)) { return HYBRID; } else if (themeMap.isFamiliar(files)) { return GOD_MODE; }. This reduces reliance on semantic_search and extract_region which appear fragile."
          }
        ]
      }
    }
  ],
  "summary": {
    "passRate": "0/1 (0%)",
    "avgToolCalls": 19,
    "avgTimeSeconds": 143,
    "totalCostCents": 45,
    "failureReasons": [
      "Missing required file edits: assets/product-form-dynamic.css"
    ]
  },
  "aggregateAnalysis": {
    "diagnosis": {
      "summary": "Single successful run with 8 tool failures (semantic_search, extract_region, propose_code_edit, edit_lines) but overall task completion. Failures appear to be graceful degradations rather than blockers—agent recovered and applied changes despite missing tool outputs.",
      "rootCause": "Tool executor or backend service returning null/empty results for semantic_search, extract_region, and propose_code_edit operations. These are non-fatal in the current workflow because the agent has fallback strategies (re-reading files, using basic edit_lines) and the PM prompt is permissive enough to continue despite incomplete tool responses.",
      "agentBehavior": "Agent demonstrated resilience: when semantic_search returned no results, it proceeded with file reads. When extract_region failed, it used alternative approaches. Multiple propose_code_edit failures (3x) followed by successful edit_lines suggests the agent adapted mid-stream. However, the pattern indicates the agent is relying on workarounds rather than robust tool execution."
    },
    "patterns": {
      "consistentFailureMode": null,
      "intermittentIssues": [
        "semantic_search returns no results despite being called (may indicate query formulation or index availability issue)",
        "extract_region fails silently—agent cannot extract code regions but continues with full file reads",
        "propose_code_edit fails 3 times sequentially, then agent switches to direct edit_lines (suggests tool or model routing issue, not agent logic)"
      ],
      "toolUsageAntiPatterns": [
        "Multiple read_lines calls on same file (7x read_lines before any edits suggests over-reading for context gathering)",
        "propose_code_edit called 3x with failures, then successful edit_lines—indicates agent lacks early detection that propose_code_edit will fail and should skip to edit_lines directly",
        "semantic_search called but no follow-up strategy when it returns empty (agent should have a fallback to grep_content or manual file search)",
        "check_lint called twice but no visible use of lint results in subsequent decisions"
      ],
      "contextGaps": [
        "No indication agent read Shopify theme configuration or settings files that might define badge styling",
        "No grep_content or structured search for 'Awaiting Restock' badge definition across codebase before making changes",
        "Missing context on color/length option data structures—agent may not have fully mapped the product option schema"
      ]
    },
    "recommendations": [
      {
        "priority": "critical",
        "category": "tools",
        "title": "Implement tool failure recovery and early exit logic",
        "description": "propose_code_edit failed 3 times in sequence. The agent should detect failure patterns (e.g., same tool failing 2+ times) and immediately switch to edit_lines or alternative approaches rather than retrying. Add exponential backoff or circuit-breaker pattern to tool executor.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "Tool execution and error handling",
        "suggestedChange": "Add failure counters per tool per iteration. If propose_code_edit fails twice, skip to edit_lines. If semantic_search fails, auto-fallback to grep_content. Return structured error objects with retry recommendations, not silent nulls."
      },
      {
        "priority": "critical",
        "category": "validation",
        "title": "Add tool result validation gates before proceeding",
        "description": "semantic_search, extract_region, and propose_code_edit returned no results/null without blocking. The PM prompt should include validation rules: if a tool returns empty/null, log it and trigger alternative strategy. Currently the agent proceeds as if the tool succeeded.",
        "targetFile": "lib/agents/orchestration-policy.ts",
        "targetArea": "Validation gates and context enforcement",
        "suggestedChange": "Add post-tool validation: if semantic_search returns null, require grep_content or manual read before proceeding. If propose_code_edit returns null, require edit_lines. Gate iteration advancement on successful tool execution or explicit fallback."
      },
      {
        "priority": "high",
        "category": "prompt",
        "title": "Enhance PM prompt with tool failure handling and fallback strategies",
        "description": "The agent successfully completed despite tool failures, but it did so through implicit workarounds. Make fallback strategies explicit in the system prompt so agent consciously chooses alternatives rather than stumbling through.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Tool usage instructions and error handling",
        "suggestedChange": "Add section: 'If semantic_search returns empty, use grep_content with keyword. If extract_region fails, read the file and manually identify the region. If propose_code_edit fails, use edit_lines with explicit line numbers. Do not retry the same tool more than once without changing parameters.'"
      },
      {
        "priority": "high",
        "category": "coordinator",
        "title": "Reduce redundant file reads and implement smart context caching",
        "description": "Agent called read_lines 7 times before first edit. This suggests either insufficient context from earlier reads or lack of caching. Implement session-level file content cache to avoid re-reading and reduce iterations.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Context building and iteration loop",
        "suggestedChange": "Add file content cache in coordinator state. Before read_lines, check cache. After read_lines, cache result. Track which files have been read and their line ranges. Use cache hits to reduce iteration count and accelerate tool execution."
      },
      {
        "priority": "high",
        "category": "context",
        "title": "Pre-scout file targeting for badge and option structures",
        "description": "Agent should have immediately identified files containing 'Awaiting Restock' badge definition and product option data structures. Missing this context likely caused over-reading and inefficient edits.",
        "targetFile": "lib/agents/scout/structural-scout.ts",
        "targetArea": "Scout brief generation and file targeting",
        "suggestedChange": "Enhance scout to search for: (1) 'Awaiting Restock' or similar badge strings via grep, (2) product option/variant schema definitions, (3) color/length data structures. Return targeted file list with line ranges. Use theme-map to accelerate lookup."
      },
      {
        "priority": "medium",
        "category": "tools",
        "title": "Improve semantic_search implementation or fallback strategy",
        "description": "semantic_search returned no results. Either the query was poorly formulated, the index is stale, or the feature is not available. Add logging and fallback to grep_content with extracted keywords.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "semantic_search execution",
        "suggestedChange": "If semantic_search returns empty, automatically extract keywords from the query and call grep_content. Log the fallback so we can diagnose why semantic_search failed. Consider adding semantic_search result validation (e.g., must return ≥1 file)."
      },
      {
        "priority": "medium",
        "category": "validation",
        "title": "Add lint result usage and validation",
        "description": "Agent called check_lint twice but no visible downstream use. Lint results should inform edit validation and error detection.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Lint integration and validation gates",
        "suggestedChange": "After edit_lines, automatically run check_lint on edited files. If lint errors appear, trigger review or correction loop. Gate iteration advancement on lint pass or explicit override."
      },
      {
        "priority": "medium",
        "category": "strategy",
        "title": "Implement stagnation detection to break retry loops",
        "description": "3 consecutive propose_code_edit failures followed by edit_lines suggests agent was stuck in a retry loop. Add stagnation detection to force strategy shift.",
        "targetFile": "lib/agents/strategy.ts",
        "targetArea": "Strategy selection and adaptation",
        "suggestedChange": "Track tool usage history per iteration. If same tool fails 2+ times or if iteration count exceeds threshold without progress, shift to simpler strategy (e.g., SIMPLE mode with direct edit_lines). Log strategy shifts for debugging."
      }
    ]
  }
}