{
  "timestamp": "2026-02-27T08:13:07.323Z",
  "projectId": "838e7498-6dc5-4268-9fcd-e6f6148f65ad",
  "scenario": "restock-badge-lengths",
  "prompt": "On the product page template, update product-form-dynamic so out-of-stock color swatches with \"Awaiting Restock\" also show a second line listing available longer lengths for that color. Implement all three layers in one pass: (1) Liquid markup in snippets/product-form-dynamic.liquid, (2) styling in assets/product-form-dynamic.css, and (3) behavior/data handling in assets/product-form-dynamic.js. The length list must come from variant option1 availability and must exclude any lengths present in the product metafield list custom_values. Ensure text contrast is background-aware over swatch images.",
  "totalRuns": 1,
  "results": [
    {
      "run": 1,
      "passed": false,
      "reason": "Missing required file edits: snippets/product-form-dynamic.liquid",
      "metrics": {
        "totalToolCalls": 31,
        "editToolCalls": 10,
        "readToolCalls": 19,
        "searchToolCalls": 0,
        "elapsedMs": 241625,
        "costCents": 418,
        "inputTokens": 1346505,
        "outputTokens": 9275
      },
      "tier": "COMPLEX",
      "strategy": "GOD_MODE",
      "changedFiles": [
        "assets/product-form-dynamic.css",
        "product-form-dynamic.css",
        "assets/product-form-dynamic.js",
        "product-form-dynamic.js"
      ],
      "transcript": {
        "runId": "run-1",
        "scenario": "restock-badge-lengths",
        "decisions": [
          {
            "phase": "analyzing",
            "label": "Loading context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Context ready",
            "detail": "606 files, 5 prefs",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Classifying request...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Preparing file context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building structural brief...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Starting agent...",
            "timestamp": 0
          },
          {
            "phase": "strategy",
            "label": "Strategy: GOD_MODE",
            "detail": "strategy=GOD_MODE, tier=COMPLEX",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "COMPLEX tier — GOD_MODE strategy — claude-sonnet-4-6",
            "detail": "routingTier=COMPLEX, strategy=GOD_MODE",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Style profile loaded",
            "detail": "styleProfileRules=8, designTokenCount=0, patternConflictResolutions=0, referenceSectionsLoaded=0, cssPreloaded=false, snippetConsumers=0",
            "timestamp": 0
          }
        ],
        "toolSequence": [
          {
            "name": "read_lines",
            "id": "toolu_011BbF1ezrKybMH3aqrRzSoH",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 1,
                  "endLine": 50
                },
                {
                  "startLine": 606,
                  "endLine": 801
                }
              ]
            },
            "result": "--- product-form-dynamic.css lines 1-52 ---\n    1| /* Hidden state for unavailable colors when custom option is selected */\n    2| .t4s-swatch__btn-wrap.pfd-hidden-custom {\n    3|   display: none !important;\n    4| }\n    5| \n    6| .pfd-override-wrapper {\n    7| \n    8|   --pfd-border-color: rgb(230, 230, 230);\n    9|   --pfd-border-color-selected: rgb(20, 20, 20);\n   10|   --pfd-background: #ffffff;\n   11|   --pfd-text-color: rgb(20, 20, 20);\n   12|   --pfd-muted-color: rgb(115, 115, 115);\n   13| \n   14|   .pfd-custom-wrapper {\n   15|     font-family: 'AeonikPro-Medium' !important;\n   16| \n   17|     .bold {\n   18|       font-weight: bold !important;\n   19|       font-family: var(--pfd-font-family-weighted) !important;\n   20|     }\n   21| \n   22|     .t4s-swatch__title {\n   23|       display: flex !important;\n   24|       flex-direction: row !important;\n   25|       justify-content: space-between !important;\n   26|       font-weight: normal !important;\n   27|       font-family: var(--pfd-font-family) !important;\n   28|       font-size: 14px !important;\n   29|       text-transform: none !important;\n   30|       color: var(--pfd-muted-color) !important;\n   31| \n   32|       .t4s-swatch__title--left span {\n   33|         color: var(--pfd-text-color) !important;\n   34|       }\n   35| \n   36|       .t4s-swatch__title--right {\n   37|         color: var(--pfd-text-color) !important;\n   38|         text-align: right !important;\n   39|       }\n   40|     }\n   41| \n   42|     .t4s-swatch__title--color {\n   43|       color: var(--pfd-text-color) !important;\n   44|       font-size: 14px !important;\n   45|     }\n   46| \n   47|     .t4s-swatch__list {\n   48|       gap: 8px !important;\n   49|       margin: 0 !important;\n   50|     }\n   51| \n   52|     .t4s-swatch__item,\n\n--- product-form-dynamic.css lines 604-801 ---\n  604|       }\n  605| \n  606|       .pfd-custom-dropdown {\n  607|         height: 36px !important;\n  608|         font-size: 13px !important;\n  609|       }\n  610|  \n... [truncated 7293 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_file",
            "id": "toolu_01DPKTDUq6DVZGL5ruW39ujh",
            "input": {
              "fileId": "snippets/product-form-dynamic.liquid",
              "view": "markup"
            },
            "result": "{% comment %} Custom options configuration - options listed here will render as dropdowns {% endcomment %}\n{% assign custom_option_names = product.metafields.custom.custom_values.value %}\n\n{% comment %} Custom content configuration for specific options {% endcomment %}\n{% comment %} Format: option_name:option_value|<html content> - separated by semicolons for multiple {% endcomment %}\n\n{% assign option_content_config = 'texture:Straight|<div class=\"pfd-info-content\"><span class=\"pfd-info-icon\">i</span><span class=\"pfd-info-text\">Our straight texture has slight natural wave texture to it when washed and dried. It is not pin straight hair, nor is that desirable among most clientele.</span></div>;texture:Natural Wave|<div class=\"pfd-info-content\"><span class=\"pfd-info-icon\">i</span><span class=\"pfd-info-text\">Our natural wave texture features soft, beachy waves that blend seamlessly with most natural hair textures. Low maintenance and versatile for everyday styling.</span></div>;texture:Loose Curl|<div class=\"pfd-info-content\"><span class=\"pfd-info-icon\">i</span><span class=\"pfd-info-text\">Our loose curl texture offers bouncy, defined curls that hold their shape beautifully. Perfect for adding volume and movement with minimal styling required.</span></div>;texture:Tight Curl|<div class=\"pfd-info-content\"><span class=\"pfd-info-icon\">i</span><span class=\"pfd-info-text\">Our tight curl texture provides well-defined, springy curls with maximum volume. Ideal for protective styles and blending with naturally curly hair.</span></div>' %}\n\n{% assign option_content_pairs = option_content_config | split: ';' %}\n\n{% comment %} SellersDash collect child product details {% endcomment %}\n{% assign shsd_product_details = product.metafields.sellersdash.shsdproducts %}\n{% if shsd_product_details.product_type == 'shsd_parent' %}\n  {% assign shsd_product_handles = product.handle %}\n  {% assign shsd_product_handles = shsd_product_handles | concat: shsd_product_details.handles %}\n  {% for s\n... [truncated 68674 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_file",
            "id": "toolu_01L6EcNgz92hRWFymRNCcB3N",
            "input": {
              "fileId": "assets/product-form-dynamic.js"
            },
            "result": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n\n... [truncated 72936 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01KGnL7BYGsePEsEPm9bNGcy",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 160,
                  "endLine": 200
                },
                {
                  "startLine": 719,
                  "endLine": 801
                }
              ]
            },
            "result": "--- product-form-dynamic.css lines 158-202 ---\n  158| \n  159|       &.is--soldout {\n  160|         opacity: 1 !important;\n  161|         background: #f5f5f5 !important;\n  162|         color: var(--pfd-muted-color) !important;\n  163|         cursor: pointer !important;\n  164|         border: 2px solid rgba(198, 15, 46, 0.48)!important;\n  165|       }\n  166| \n  167|       div[data-img-el] {\n  168|         width: 100% !important;\n  169|         height: 110px !important;\n  170|         min-width: 40px !important;\n  171|         max-width: 100% !important;\n  172|         padding: 0px !important;\n  173|         border-radius: .625rem !important;\n  174|         border: 1px solid var(--pfd-border-color) !important;\n  175|         flex-shrink: 0 !important;\n  176|         overflow: hidden !important;\n  177|         transition: transform 0.2s ease-out !important;\n  178| \n  179|         img {\n  180|           width: 100% !important;\n  181|           height: 100% !important;\n  182|           object-fit: cover !important;\n  183|           object-position: top left;\n  184|         }\n  185| \n  186|         img[src=\"\"],\n  187|         img:not([src]),\n  188|         img[src=\"null\"] {\n  189|           opacity: 0 !important;\n  190|           visibility: hidden !important;\n  191|         }\n  192|       }\n  193|     }\n  194| \n  195|     .pfd-split-option {\n  196|       position: relative !important;\n  197|       font-family: 'AeonikPro-Medium'\n  198|     }\n  199| \n  200|     .pfd-split-selection {\n  201|       display: flex !important;\n  202|       align-items: center !important;\n\n--- product-form-dynamic.css lines 717-801 ---\n  717| }\n  718| \n  719| /* ============================================\n  720|    AVAILABLE LENGTHS TEXT\n  721|    Shown below the swatch image, as a sibling in .t4s-swatch__btn-wrap\n  722|    Displayed when a color is out of stock at the selected length\n  723|    but available in other lengths\n  724|    ============================================ */\n  725| \n  72\n... [truncated 3140 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_014JffPi8ZoYb3ubhSuJRQwb",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 115,
                  "endLine": 195
                },
                {
                  "startLine": 625,
                  "endLine": 715
                }
              ]
            },
            "result": "--- product-form-dynamic.css lines 113-197 ---\n  113| }\n  114|     .t4s-swatch__btn-wrap {\n  115|       font-weight: 600 !important;\n  116|       height: auto !important;\n  117|       width: calc(25% - 6px) !important;\n  118|       margin: 0 !important;\n  119|       padding: 8px 8px !important;\n  120|       border-radius: 8px !important;\n  121|       border: 1px solid var(--pfd-border-color) !important;\n  122|       font-size: 12px !important;\n  123|       font-weight: 500 !important;\n  124|       min-width: 48px !important;\n  125|       transition: all 0.2s ease-out !important;\n  126|       background: var(--pfd-background) !important;\n  127|       box-shadow:\n  128|         0 0px 0px 0 rgb(0 0 0 / 0.05),\n  129|         0 0 0 0px rgb(0 0 0 / 0.05) !important;\n  130|       display: inline-flex !important;\n  131|       align-items: center !important;\n  132|       justify-content: flex-start !important;\n  133|       cursor: pointer !important;\n  134|       color: rgb(20, 20, 20) !important;\n  135|       flex-direction: column;\n  136|       gap: 4px;\n  137| \n  138|       &:hover {\n  139|         border-color: rgb(0 0 0 / 0.5) !important;\n  140|         box-shadow:\n  141|           0 4px 6px -1px rgb(0 0 0 / 0.1),\n  142|           0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n  143|         transform: translateY(-2px) !important;\n  144|       }\n  145| \n  146|       &:active {\n  147|         transform: scale(0.98) !important;\n  148|         box-shadow: none !important;\n  149|       }\n  150| \n  151|       &.is--selected {\n  152|         border-color: var(--pfd-border-color-selected) !important;\n  153|         background: var(--pfd-background) !important;\n  154|         box-shadow:\n  155|           0 0 0 1px rgb(0 0 0 / 0.2),\n  156|           0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n  157|       }\n  158| \n  159|       &.is--soldout {\n  160|         opacity: 1 !important;\n  161|         background: #f5f5f5 !important;\n  162|         color: var(--pfd-muted-color) !important;\n\n... [truncated 4668 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01RoeAUc7pwNKCxRN3NkvMEF",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 726,
                  "endLine": 801
                }
              ]
            },
            "result": "--- product-form-dynamic.css lines 724-801 ---\n  724|    ============================================ */\n  725| \n  726| /* Base: hidden by default */\n  727| .t4s-swatch__available-lengths {\n  728|   display: none;\n  729|   width: 100%;\n  730|   text-align: center;\n  731|   margin-top: 4px;\n  732|   /* Fallback before JS sets data-luminance: dark text with a white halo so it\n  733|      reads on both light and dark swatch backgrounds without JS. */\n  734|   color: rgba(20, 20, 20, 0.9);\n  735|   text-shadow:\n  736|     0 0 3px rgba(255, 255, 255, 0.9),\n  737|     0 0 6px rgba(255, 255, 255, 0.7);\n  738|   font-size: 7px;\n  739|   font-weight: 500;\n  740|   text-transform: uppercase;\n  741|   letter-spacing: 0.3px;\n  742|   white-space: normal;\n  743|   word-break: break-word;\n  744|   pointer-events: none;\n  745|   line-height: 1.3;\n  746|   max-width: 100%;\n  747| }\n  748| \n  749| /* Show when Liquid SSR or JS adds .is-visible */\n  750| .t4s-swatch__available-lengths.is-visible {\n  751|   display: block;\n  752| }\n  753| \n  754| /* Direct child of btn-wrap: hidden by default, shown via .is-visible */\n  755| .t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  756|   display: none;\n  757| }\n  758| \n  759| .t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  760|   display: block;\n  761| }\n  762| \n  763| /* Content-aware contrast: attribute set on btn-wrap by JS luminance detection.\n  764|    Once luminance is known, replace the halo text-shadow with a clean color. */\n  765| .t4s-swatch__btn-wrap[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  766|   color: rgba(20, 20, 20, 0.75);\n  767|   text-shadow: none;\n  768| }\n  769| \n  770| .t4s-swatch__btn-wrap[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  771|   color: rgba(255, 255, 255, 0.9);\n  772|   text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);\n  773| }\n  774| \n  775| /* Reflow btn-wrap to column layout when lengths text is visible.\n  776|    Scoped inside .pfd-override-wrapper t\n... [truncated 1257 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01KhTeV99NheeU7Wm7x2Pw1p",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "startLine": 726,
              "endLine": 801,
              "newContent": "/* Base: hidden by default */\n.t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 2px;\n  /* Fallback before JS sets data-luminance: dark text with a white halo so it\n     reads on both light and dark swatch backgrounds without JS. */\n  color: rgba(20, 20, 20, 0.9);\n  text-shadow:\n    0 0 3px rgba(255, 255, 255, 0.9),\n    0 0 6px rgba(255, 255, 255, 0.7);\n  font-size: 9px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: normal;\n  word-break: break-word;\n  pointer-events: none;\n  line-height: 1.4;\n  max-width: 100%;\n  padding: 0 4px;\n}\n\n/* Show when Liquid SSR or JS adds .is-visible */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Direct child of btn-wrap: hidden by default, shown via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: attribute set on btn-wrap by JS luminance detection.\n   Once luminance is known, replace the halo text-shadow with a clean color. */\n.t4s-swatch__btn-wrap[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(20, 20, 20, 0.75);\n  text-shadow: none;\n}\n\n.t4s-swatch__btn-wrap[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.9);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);\n}\n\n/* Separator line above lengths text — visually separates it from the swatch image */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible::before {\n  content: '';\n  display: block;\n  width: 80%;\n  height: 1px;\n  background: currentColor;\n  opacity: 0.2;\n  margin: 0 auto 3px;\n}\n\n/* Reflow btn-wrap to column layout when lengths text is visible.\n   Scoped inside .pfd-override-wrapper to beat the nested align-items: center\n   !important on .t4s-swatch__btn-wrap from the base rule above.\n   .pfd-has-lengths is added by Liquid SSR and kept in sync by JS. */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex !important;\n  flex-direction: column !important;\n  align-items: stretch !important;\n  gap: 0 !important;\n}\n\n/* Image container stretches to fill card width in column layout */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > div[data-img-el],\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > div[data-img-el] {\n  width: 100% !important;\n}\n\n/* In column layout, reset badge position */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > .t4s-swatch__restock-badge,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > .t4s-swatch__restock-badge {\n  margin-left: 0 !important;\n  margin-top: 2px;\n}\n\n/* Tight spacing below the badge */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > .t4s-swatch__available-lengths,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > .t4s-swatch__available-lengths {\n  margin-top: 3px;\n  text-align: center;\n  width: 100%;\n}\n",
              "reasoning": "Improve lengths text: larger font (9px), padding, separator line, stretch alignment in column layout, tighter gap."
            },
            "result": "Lines 726-801 replaced in product-form-dynamic.css (819 total lines).",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "extract_region",
            "id": "toolu_01E3FTJ8fZeCTCAt7kXdBRUD",
            "input": {
              "fileId": "assets/product-form-dynamic.js",
              "hint": "updateAvailableLengths"
            },
            "result": "File: product-form-dynamic.js\nMatch type: block-boundary\nLines: 682–682\n\n  682:     updateAvailableLengths(el, badgeParent, imgContainer);",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "extract_region",
            "id": "toolu_01HoqDrY6Lifveh5hFYYvsmQ",
            "input": {
              "fileId": "assets/product-form-dynamic.js",
              "hint": "function updateAvailableLengths"
            },
            "result": "File: product-form-dynamic.js\nMatch type: block-boundary\nLines: 702–702\n\n  702: function updateAvailableLengths(swatchEl, badgeParent, imgContainer) {",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_018zBrDK3K2TADRTuCCYHSys",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 702,
                  "endLine": 810
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 700-812 ---\n  700| }\n  701| \n  702| function updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  703|   const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n  704|   // Prefer the explicit length option index injected by Liquid.\n  705|   // Falls back to scanning all non-color options if not set.\n  706|   const explicitLengthIdx = typeof window.__LENGTH_OPTION_INDEX__ === \"number\"\n  707|     ? window.__LENGTH_OPTION_INDEX__\n  708|     : -1;\n  709| \n  710|   // Find which option index is the color option\n  711|   let colorOptIdx = -1;\n  712|   for (let i = 0; i < optionCount; i++) {\n  713|     if (isColorOption(i)) {\n  714|       colorOptIdx = i;\n  715|       break;\n  716|     }\n  717|   }\n  718|   if (colorOptIdx < 0) return;\n  719| \n  720|   // Get the color value from this swatch element\n  721|   const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  722|   if (!colorValue) return;\n  723| \n  724|   // Determine which option indices to report as \"available lengths\".\n  725|   // If a specific length index was injected (option1 in most cases), use only that.\n  726|   // Otherwise fall back to all non-color indices.\n  727|   let targetIndices;\n  728|   if (explicitLengthIdx >= 0 && explicitLengthIdx !== colorOptIdx) {\n  729|     targetIndices = [explicitLengthIdx];\n  730|   } else {\n  731|     targetIndices = [];\n  732|     for (let i = 0; i < optionCount; i++) {\n  733|       if (i !== colorOptIdx) targetIndices.push(i);\n  734|     }\n  735|   }\n  736|   if (targetIndices.length === 0) return;\n  737| \n  738|   // Check if this color IS available at the current non-color selections.\n  739|   // If so, there's nothing to report — hide any existing text and bail.\n  740|   const nonColorIndices = [];\n  741|   for (let i = 0; i < optionCount; i++) {\n  742|     if (i !== colorOptIdx) nonColorIndices.push(i);\n  743|   }\n  744|   const currentSelections = nonColorIndices.map((idx) =>\n  745|     normVal(select\n... [truncated 2875 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01KjdFBA7QuzDxbg252qdg3J",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 812,
                  "endLine": 845
                },
                {
                  "startLine": 1085,
                  "endLine": 1130
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 810-847 ---\n  810|   // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  811|   // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  812|   let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n  813| \n  814|   if (parts.length > 0) {\n  815|     if (!lengthsEl) {\n  816|       lengthsEl = document.createElement(\"span\");\n  817|       lengthsEl.className = \"t4s-swatch__available-lengths\";\n  818|       // Insert after the image container ([data-img-el]) so the order matches\n  819|       // the Liquid-rendered DOM: image → lengths → label → nickname.\n  820|       // Fall back to appendChild if no image container exists.\n  821|       const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n  822|       if (imgEl && imgEl.nextSibling) {\n  823|         swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n  824|       } else {\n  825|         swatchEl.appendChild(lengthsEl);\n  826|       }\n  827|     }\n  828|     lengthsEl.textContent = \"Available in \" + parts.join(\", \");\n  829|     lengthsEl.classList.add(\"is-visible\");\n  830|     swatchEl.classList.add(\"pfd-has-lengths\");\n  831| \n  832|   } else {\n  833|     if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n  834|     swatchEl.classList.remove(\"pfd-has-lengths\");\n  835|   }\n  836| }\n  837| \n  838| // Luminance detection for content-aware badge contrast\n  839| const luminanceCache = new Map();\n  840| \n  841| function detectSwatchLuminance(imgContainer, badge) {\n  842|   const img = imgContainer.querySelector(\"img\");\n  843|   // The btn-wrap parent needs the attribute so the CSS cascade reaches\n  844|   // the sibling .t4s-swatch__available-lengths element\n  845|   const btnWrap = imgContainer.closest(\".t4s-swatch__btn-wrap\");\n  846| \n  847|   const applyLuminance = (result) => {\n\n--- product-form-dynamic.js lines 1083-1132 ---\n 1083|       // Use the first matching variant's image (prioritizing a\n... [truncated 1978 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01Q2CYjbkCynBHXzy1Cac2qH",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1295,
                  "endLine": 1360
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1293-1362 ---\n 1293|           img.src = imageUrl;\n 1294|           mediaItem.appendChild(img);\n 1295|           mainListing.appendChild(mediaItem);\n 1296|         }\n 1297|       }\n 1298|     }\n 1299| \n 1300|     // Ensure thumb listing exists\n 1301|     if (thumbImgsEl) {\n 1302|       let thumbListing = thumbImgsEl.querySelector(\n 1303|         `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n 1304|       );\n 1305| \n 1306|       if (!thumbListing) {\n 1307|         thumbListing = document.createElement(\"div\");\n 1308|         thumbListing.className = \"pfd-img-listing\";\n 1309|         thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n 1310|         thumbImgsEl.appendChild(thumbListing);\n 1311| \n 1312|         // Populate with thumbnails\n 1313|         for (const imageUrl of variant.variantImages) {\n 1314|           const mediaThumb = document.createElement(\"div\");\n 1315|           mediaThumb.className = \"pfd-media-thumb\";\n 1316|           const imgDiv = document.createElement(\"div\");\n 1317|           imgDiv.className = \"pfd-img\";\n 1318|           imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n 1319|           mediaThumb.appendChild(imgDiv);\n 1320|           thumbListing.appendChild(mediaThumb);\n 1321|         }\n 1322|       }\n 1323|     }\n 1324|   }\n 1325| \n 1326|   // Ensure select option exists for hydrated variants\n 1327|   function ensureSelectOption(variantId, variant) {\n 1328|     if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n 1329| \n 1330|     const option = document.createElement(\"option\");\n 1331|     option.value = variantId;\n 1332|     option.setAttribute(\"data-option1\", variant.option1 || \"\");\n 1333|     option.setAttribute(\"data-option2\", variant.option2 || \"\");\n 1334| \n 1335|     const optionValues = [\n 1336|       variant.option1,\n 1337|       variant.option2,\n 1338|       variant.option3,\n 1339|     ].filter(Boolean);\n 1340|     option.textContent = optionValues.join(\" / \");\n... [truncated 862 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_012WMqJvozJ8uRk4z89dA1mr",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1530,
                  "endLine": 1600
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1528-1602 ---\n 1528| \n 1529|               // Display the value with unit if available\n 1530|               const displayValue = optionUnit\n 1531|                 ? `${cleanedValue} ${optionUnit}`\n 1532|                 : cleanedValue;\n 1533| \n 1534|               currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n 1535|             }\n 1536| \n 1537|             // Close the dropdown\n 1538|             dropdownWrapper.classList.remove(\"is-open\");\n 1539|             customButton.setAttribute(\"aria-expanded\", \"false\");\n 1540|           }\n 1541| \n 1542|           // Show custom notice for dropdown selection and update text\n 1543|           const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n 1544|           const customNotice = optionEl\n 1545|             ? optionEl.querySelector(\".pfd-custom-notice\")\n 1546|             : null;\n 1547|           if (customNotice && optionEl) {\n 1548|             const optionName =\n 1549|               optionEl.getAttribute(\"data-option-name\") || \"item\";\n 1550|             const noticeText = customNotice.querySelector(\n 1551|               \".pfd-custom-notice-text\",\n 1552|             );\n 1553|             if (noticeText) {\n 1554|               noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n 1555|             }\n 1556|             customNotice.style.display = \"block\";\n 1557|           }\n 1558| \n 1559|           // Clear all selected states from the option group (both standard and custom)\n 1560|           if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n 1561|             optionEl\n 1562|               .querySelectorAll(\"[data-swatch-item].is--selected\")\n 1563|               .forEach((el) => el.classList?.remove(\"is--selected\"));\n 1564| \n 1565|             // Remove active state from ALL dropdown buttons\n... [truncated 1487 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01MNTp8EutwynzuBEuyxFbcT",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1640,
                  "endLine": 1720
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1638-1722 ---\n 1638|           .querySelectorAll(\n 1639|             \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n 1640|           )\n 1641|           .forEach((wrapper) => {\n 1642|             wrapper.classList?.remove(\"is-open\");\n 1643|             const customButton = document.querySelector(\n 1644|               `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n 1645|             );\n 1646|             if (customButton) {\n 1647|               customButton.setAttribute(\"aria-expanded\", \"false\");\n 1648|               customButton.focus();\n 1649|             }\n 1650|           });\n 1651|       }\n 1652|     });\n 1653|   }\n 1654| \n 1655|   // Initialize split selection handlers\n 1656|   setupSplitSelectionHandlers();\n 1657| \n 1658|   // ---------- Bootstrap selection ----------\n 1659|   const domSelected = getSelectedFromDOM();\n 1660|   for (let i = 0; i < optionCount; i++)\n 1661|     selectedValues[i] = domSelected[i] || \"\";\n 1662|   patchAllAvailability();\n 1663| \n 1664|   // Initial image update with any existing data\n 1665|   updateSwatchImages();\n 1666|   updateVariantImages();\n 1667| \n 1668|   // Run luminance detection on SSR-rendered out-of-stock swatches.\n 1669|   // Badges and lengths text are rendered with is-visible by Liquid SSR, so\n 1670|   // we only need to set data-luminance on imgContainer + btnWrap so the\n 1671|   // contrast CSS cascade fires immediately — before hydration completes.\n 1672|   (function initLuminanceForSSRSwatches() {\n 1673|     const outOfStockWraps = root.querySelectorAll(\n 1674|       \".t4s-swatch__btn-wrap.is--out-of-stock\"\n 1675|     );\n 1676|     for (const wrap of outOfStockWraps) {\n 1677|       const imgContainer = wrap.querySelector(\"[data-img-el]\");\n 1678|       if (!imgContainer) continue;\n 1679|       // Ensure badge is visible (Liquid SSR now adds is-visible, but guard\n 1680|       // against older cached HTML that may not have it yet).\n 1681|       const badge = imgContainer.\n... [truncated 1851 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_017LNK51eRxTpnAQhqvNDKYw",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1860,
                  "endLine": 1920
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1858-1922 ---\n 1858| \n 1859|         // Build featured_media object to match theme format\n 1860|         const featuredMedia = n.image\n 1861|           ? {\n 1862|               id: n.image.id\n 1863|                 ? String(n.image.id).includes(\"/\")\n 1864|                   ? String(n.image.id).split(\"/\").pop()\n 1865|                   : n.image.id\n 1866|                 : null,\n 1867|               alt: n.image.altText || null,\n 1868|               preview_image: {\n 1869|                 aspect_ratio:\n 1870|                   n.image.width && n.image.height\n 1871|                     ? n.image.width / n.image.height\n 1872|                     : 1,\n 1873|                 height: n.image.height || 600,\n 1874|                 width: n.image.width || 600,\n 1875|                 src: n.image.url,\n 1876|               },\n 1877|             }\n 1878|           : null;\n 1879| \n 1880|         // Get option values for title and public_title\n 1881|         const optionValues = (n.selectedOptions || []).map((o) => o.value);\n 1882| \n 1883|         const rawVariant = {\n 1884|           id: numericId,\n 1885|           title: n.title,\n 1886|           available: !!n.availableForSale,\n 1887|           sku: n.sku,\n 1888|           requires_shipping: true,\n 1889|           taxable: n.taxable !== false,\n 1890|           featured_image: featuredImage,\n 1891|           options: optionValues,\n 1892|           price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n 1893|           weight: n.weight || 0,\n 1894|           compare_at_price: n.compareAtPrice\n 1895|             ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n 1896|             : null,\n 1897|           inventory_management: \"shopify\",\n 1898|           barcode: n.barcode || \"\",\n 1899|           featured_media: featuredMedia,\n 1900|           inventory_policy: null,\n 1901|           inventory_quantity:\n 1902|             n.quantityAvailable !== undefined ? n.quantityAvailable :\n... [truncated 794 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01D8PVcB8hy666fpCgU3kCQY",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 799,
              "endLine": 808,
              "newContent": "  // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  // then fall back to locale-aware string sort for non-numeric values.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    const sorted = [...values].sort((a, b) => {\n      const na = parseFloat(a);\n      const nb = parseFloat(b);\n      if (!isNaN(na) && !isNaN(nb)) return na - nb;\n      return a.localeCompare(b);\n    });\n    if (targetIndices.length === 1) {\n      parts.push(sorted.join(\", \"));\n    } else {\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n    }\n  }\n",
              "reasoning": "Sort available lengths numerically (14, 16, 18…) before display so the list reads in ascending order. Falls back to locale string sort for non-numeric values."
            },
            "result": "Lines 799-808 replaced in product-form-dynamic.js (2172 total lines).",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_014SqshSLA27ghSc8FFEAwE6",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1940,
                  "endLine": 1970
                },
                {
                  "startLine": 2155,
                  "endLine": 2172
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1938-1972 ---\n 1938| \n 1939|       // Patch as data arrives (won't disable everything if partial)\n 1940|       patchAllAvailability();\n 1941| \n 1942|       if (!pageInfo?.hasNextPage) break;\n 1943|       after = pageInfo.endCursor;\n 1944|     }\n 1945| \n 1946|     // Final pass once all data is in\n 1947|     patchAllAvailability();\n 1948| \n 1949|     // Update swatch images with the loaded data\n 1950|     updateSwatchImages();\n 1951| \n 1952|     // Update variant images sections with the loaded data\n 1953|     updateVariantImages();\n 1954| \n 1955|     // Update thumbnails after hydration completes\n 1956|     if (typeof $ !== \"undefined\") {\n 1957|       setTimeout(() => {\n 1958|         triggerThumbnailUpdate();\n 1959|       }, 200);\n 1960|     }\n 1961|   }\n 1962| \n 1963|   function setDefaultVariant() {\n 1964|     console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n 1965|     console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n 1966| \n 1967|     // If there is a selected variant, do nothing (handled by server)\n 1968|     if (window.__HAS_SELECTED__) {\n 1969|       console.log(\n 1970|         \"[PFD] Selected variant exists, skipping default variant logic\",\n 1971|       );\n 1972|       return;\n\n--- product-form-dynamic.js lines 2153-2172 ---\n 2153|     applyVariantToSelect(defaultVariant.id);\n 2154| \n 2155|     // Step 7: Re-patch availability (exactly like click handler)\n 2156|     patchAllAvailability();\n 2157| \n 2158|     // Update thumbnails after hydration completes\n 2159|     if (typeof $ !== \"undefined\") {\n 2160|       setTimeout(() => {\n 2161|         triggerThumbnailUpdate();\n 2162|       }, 200);\n 2163|     }\n 2164|   }\n 2165| \n 2166|   hydrateAllVariants(false)\n 2167|     .then(() => {\n 2168|       setDefaultVariant();\n 2169|     })\n 2170|     .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n 2171| })();\n 2172| ",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01HyMESbvjVQfFhAtG4zB9UN",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1,
                  "endLine": 3
                },
                {
                  "startLine": 2165,
                  "endLine": 2172
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1-5 ---\n    1| (() => {\n    2|   /*\n    3|    * Product Form Dynamic (PFD) - Unique Class Names:\n    4|    * - .pfd-variant-images (container for variant image data)\n    5|    * - .pfd-main-imgs (main images container)\n\n--- product-form-dynamic.js lines 2163-2172 ---\n 2163|     }\n 2164|   }\n 2165| \n 2166|   hydrateAllVariants(false)\n 2167|     .then(() => {\n 2168|       setDefaultVariant();\n 2169|     })\n 2170|     .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n 2171| })();\n 2172| ",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_014wpS6QZeSoQnD5N6hQAL76",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 1946,
              "endLine": 1960,
              "newContent": "    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Re-run luminance on all out-of-stock swatches now that images are loaded.\n    // updateSwatchImages() may have set new img.src values — clear the luminance\n    // cache so stale results don't carry over, then re-detect for each swatch.\n    luminanceCache.clear();\n    root.querySelectorAll(\".t4s-swatch__btn-wrap.is--out-of-stock\").forEach((wrap) => {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) return;\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      detectSwatchLuminance(imgContainer, badge);\n    });\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n",
              "reasoning": "After hydration updates swatch images, re-run luminance detection (with cache cleared) so the available-lengths text and restock badge get correct light/dark contrast based on the actual loaded image colors."
            },
            "result": "Lines 1946-1960 replaced in product-form-dynamic.js (2184 total lines).",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01Hy3Uzf5BsvP7zXWjXmSS3B",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1113,
                  "endLine": 1140
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 1111-1142 ---\n 1111| \n 1112|   function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n 1113|     // Add loading state\n 1114|     swatchItem.classList.add(\"swatch-loading\");\n 1115|     swatchItem.classList.remove(\n 1116|       \"swatch-loaded\",\n 1117|       \"swatch-error\",\n 1118|       \"swatch-placeholder\",\n 1119|     );\n 1120| \n 1121|     // Handle load success\n 1122|     imgEl.onload = function () {\n 1123|       swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n 1124|       swatchItem.classList.add(\"swatch-loaded\");\n 1125|     };\n 1126| \n 1127|     // Handle load error\n 1128|     imgEl.onerror = function () {\n 1129|       swatchItem.classList.remove(\"swatch-loading\");\n 1130|       swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n 1131|       imgEl.src = \"\";\n 1132|     };\n 1133| \n 1134|     // Set the image source to trigger loading\n 1135|     imgEl.src = imageUrl;\n 1136|   }\n 1137| \n 1138|   function updateVariantImages() {\n 1139|     // Hide any legacy variant image containers to ensure only our implementation is used\n 1140|     const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n 1141|     legacyContainers.forEach((container) => {\n 1142|       container.style.display = \"none !important\";",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01UZ1UczaCPkXAH7BGoUMqGB",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 1122,
              "endLine": 1125,
              "newContent": "    // Handle load success — also re-run luminance so contrast is based on\n    // the actual loaded image, not the placeholder/previous state.\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n      // Re-detect luminance for this swatch's image container\n      const btnWrap = swatchItem.closest(\".t4s-swatch__btn-wrap\") || swatchItem;\n      if (btnWrap.classList.contains(\"is--out-of-stock\")) {\n        const imgContainer = btnWrap.querySelector(\"[data-img-el]\");\n        if (imgContainer) {\n          luminanceCache.delete(imgEl.src);\n          const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n          detectSwatchLuminance(imgContainer, badge);\n        }\n      }\n    };\n",
              "reasoning": "When a swatch image finishes loading, re-run luminance detection so the restock badge and available-lengths text get correct light/dark contrast based on the real image content."
            },
            "result": "Lines 1122-1125 replaced in product-form-dynamic.js (2197 total lines).",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01BwUMrCARBEGVmy2iVX2xUt",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 2188,
                  "endLine": 2197
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 2186-2196 ---\n 2186|       }, 200);\n 2187|     }\n 2188|   }\n 2189| \n 2190|   hydrateAllVariants(false)\n 2191|     .then(() => {\n 2192|       setDefaultVariant();\n 2193|     })\n 2194|     .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n 2195| })();\n 2196| ",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_015VC7Lo2ujroNTb8pMoiTL5",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 796,
                  "endLine": 850
                }
              ]
            },
            "result": "--- product-form-dynamic.js lines 794-852 ---\n  794|     }\n  795| \n  796|     return { idx, values };\n  797|   });\n  798| \n  799|   // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  800|   // then fall back to locale-aware string sort for non-numeric values.\n  801|   const parts = [];\n  802|   for (const { idx, values } of availableByOption) {\n  803|     if (values.length === 0) continue;\n  804|     const sorted = [...values].sort((a, b) => {\n  805|       const na = parseFloat(a);\n  806|       const nb = parseFloat(b);\n  807|       if (!isNaN(na) && !isNaN(nb)) return na - nb;\n  808|       return a.localeCompare(b);\n  809|     });\n  810|     if (targetIndices.length === 1) {\n  811|       parts.push(sorted.join(\", \"));\n  812|     } else {\n  813|       const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n  814|       parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n  815|     }\n  816|   }\n  817| \n  818|   }\n  819|   // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  820|   // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  821|   let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n  822| \n  823|   if (parts.length > 0) {\n  824|     if (!lengthsEl) {\n  825|       lengthsEl = document.createElement(\"span\");\n  826|       lengthsEl.className = \"t4s-swatch__available-lengths\";\n  827|       // Insert after the image container ([data-img-el]) so the order matches\n  828|       // the Liquid-rendered DOM: image → lengths → label → nickname.\n  829|       // Fall back to appendChild if no image container exists.\n  830|       const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n  831|       if (imgEl && imgEl.nextSibling) {\n  832|         swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n  833|       } else {\n  834|         swatchEl.appendChild(lengthsEl);\n  835|       }\n  836|     }\n  837|     lengthsEl.textConte\n... [truncated 631 chars]",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01DBvSyhs1AQDNro6wXqu4Ks",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 816,
              "endLine": 819,
              "newContent": "  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n",
              "reasoning": "Remove the stray closing brace on line 818 that was left over from the original code block, which was causing the linter's extra-closing-brace error."
            },
            "result": "Lines 816-819 replaced in product-form-dynamic.js (2196 total lines).",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_014QdJRfPWjzf98nFKHwtVPx",
            "input": {
              "fileName": "assets/product-form-dynamic.js"
            },
            "result": "Syntax valid — no issues found.",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_01JDLpFPqYBEyp762xmT45qp",
            "input": {
              "fileName": "assets/product-form-dynamic.css"
            },
            "result": "Syntax valid — no issues found.",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772179824633",
            "input": {
              "filePath": "product-form-dynamic.css",
              "newContent": "/* Hidden state for unavailable colors when custom option is selected */\n.t4s-swatch__btn-wrap.pfd-hidden-custom {\n  display: none !important;\n}\n\n.pfd-override-wrapper {\n\n  --pfd-border-color: rgb(230, 230, 230);\n  --pfd-border-color-selected: rgb(20, 20, 20);\n  --pfd-background: #ffffff;\n  --pfd-text-color: rgb(20, 20, 20);\n  --pfd-muted-color: rgb(115, 115, 115);\n\n  .pfd-custom-wrapper {\n    font-family: 'AeonikPro-Medium' !important;\n\n    .bold {\n      font-weight: bold !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__title {\n      display: flex !important;\n      flex-direction: row !important;\n      justify-content: space-between !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n      font-size: 14px !important;\n      text-transform: none !important;\n      color: var(--pfd-muted-color) !important;\n\n      .t4s-swatch__title--left span {\n        color: var(--pfd-text-color) !important;\n      }\n\n      .t4s-swatch__title--right {\n        color: var(--pfd-text-color) !important;\n        text-align: right !important;\n      }\n    }\n\n    .t4s-swatch__title--color {\n      color: var(--pfd-text-color) !important;\n      font-size: 14px !important;\n    }\n\n    .t4s-swatch__list {\n      gap: 8px !important;\n      margin: 0 !important;\n    }\n\n    .t4s-swatch__item,\n    .pfd-standard-options .t4s-swatch__item {\n      font-weight: 600 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: center !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      user-select: none !important;\n    }\n\n    .t4s-swatch__item::before {\n      content: none !important;\n    }\n\n    .t4s-swatch__item:hover,\n    .pfd-standard-options .t4s-swatch__item:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n      transform: translateY(-2px) !important;\n    }\n\n    .t4s-swatch__item:active,\n    .pfd-standard-options .t4s-swatch__item:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .t4s-swatch__item.is--selected,\n    .pfd-standard-options .t4s-swatch__item.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .t4s-swatch__item.is--soldout,\n    .pfd-standard-options .t4s-swatch__item.is--soldout {\n      opacity: 0.7 !important;\n      /*background: #f5f5f5 !important;*/\n      color: var(--pfd-muted-color) !important;\n      cursor: pointer !important;\n    }\n.color-info-accordion-text{\n  font-family: 'AeonikPro-Medium'\n}\n    .t4s-swatch__btn-wrap {\n      font-weight: 600 !important;\n      height: auto !important;\n      width: calc(25% - 6px) !important;\n      margin: 0 !important;\n      padding: 8px 8px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 12px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: flex-start !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      flex-direction: column;\n      gap: 4px;\n\n      &:hover {\n        border-color: rgb(0 0 0 / 0.5) !important;\n        box-shadow:\n          0 4px 6px -1px rgb(0 0 0 / 0.1),\n          0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n        transform: translateY(-2px) !important;\n      }\n\n      &:active {\n        transform: scale(0.98) !important;\n        box-shadow: none !important;\n      }\n\n      &.is--selected {\n        border-color: var(--pfd-border-color-selected) !important;\n        background: var(--pfd-background) !important;\n        box-shadow:\n          0 0 0 1px rgb(0 0 0 / 0.2),\n          0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n      }\n\n      &.is--soldout {\n        opacity: 1 !important;\n        background: #f5f5f5 !important;\n        color: var(--pfd-muted-color) !important;\n        cursor: pointer !important;\n        border: 2px solid rgba(198, 15, 46, 0.48)!important;\n      }\n\n      div[data-img-el] {\n        width: 100% !important;\n        height: 110px !important;\n        min-width: 40px !important;\n        max-width: 100% !important;\n        padding: 0px !important;\n        border-radius: .625rem !important;\n        border: 1px solid var(--pfd-border-color) !important;\n        flex-shrink: 0 !important;\n        overflow: hidden !important;\n        transition: transform 0.2s ease-out !important;\n\n        img {\n          width: 100% !important;\n          height: 100% !important;\n          object-fit: cover !important;\n          object-position: top left;\n        }\n\n        img[src=\"\"],\n        img:not([src]),\n        img[src=\"null\"] {\n          opacity: 0 !important;\n          visibility: hidden !important;\n        }\n      }\n    }\n\n    .pfd-split-option {\n      position: relative !important;\n      font-family: 'AeonikPro-Medium'\n    }\n\n    .pfd-split-selection {\n      display: flex !important;\n      align-items: center !important;\n      gap: 12px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-standard-options {\n      display: flex !important;\n      gap: 8px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-or-separator {\n      font-size: 14px !important;\n      color: var(--pfd-muted-color) !important;\n      margin: 0 4px !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n    }\n\n    .pfd-custom-options {\n      position: relative !important;\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n      gap: 8px;\n    }\n\n    .pfd-custom-dropdown {\n      font-weight: 500 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      min-width: 200px !important;\n      min-height: 44px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: space-between !important;\n      cursor: pointer !important;\n      font-family: var(--font-body-family) !important;\n      color: rgb(20, 20, 20) !important;\n      outline: none !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-dropdown:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n    }\n\n    .pfd-custom-dropdown:focus,\n    .pfd-custom-dropdown:active {\n      outline: none !important;\n      border-color: var(--pfd-border-color-selected) !important;\n    }\n\n    .pfd-custom-dropdown:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .pfd-custom-dropdown .t4s-icon-select-arrow {\n      width: 12px !important;\n      height: 12px !important;\n      margin-left: 8px !important;\n      flex-shrink: 0 !important;\n      transition: transform 0.2s ease !important;\n    }\n\n    .pfd-custom-dropdown[aria-expanded=\"true\"] .t4s-icon-select-arrow {\n      transform: rotate(180deg) !important;\n    }\n\n    .pfd-custom-dropdown::after {\n      content: \"New\" !important;\n      position: absolute !important;\n      top: -12px !important;\n      right: -12px !important;\n      background: var(--pfd-border-color-selected) !important;\n      color: #fff !important;\n      font-size: 10px !important;\n      font-weight: 600 !important;\n      padding: 6px 12px !important;\n      border-radius: 12px !important;\n      line-height: 1 !important;\n      text-transform: uppercase !important;\n      letter-spacing: 0.5px !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper {\n      position: absolute !important;\n      top: 100% !important;\n      left: 0 !important;\n      right: auto !important;\n      min-width: 280px !important;\n      width: max-content !important;\n      z-index: 1000 !important;\n      border-radius: 12px !important;\n      box-shadow:\n        0 10px 25px -3px rgb(0 0 0 / 0.15),\n        0 4px 6px -2px rgb(0 0 0 / 0.05) !important;\n      border: 1px solid rgb(220, 220, 220) !important;\n      background: #ffffff !important;\n      overflow: hidden !important;\n      margin-top: 8px !important;\n      opacity: 0 !important;\n      transform: translateY(-10px) !important;\n      transition:\n        opacity 0.2s ease,\n        transform 0.2s ease !important;\n      visibility: hidden !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper.is-open {\n      opacity: 1 !important;\n      transform: translateY(0) !important;\n      visibility: visible !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__content {\n      max-height: 300px !important;\n      overflow-y: auto !important;\n      padding: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item {\n      padding: 0px 8px !important;\n      border: none !important;\n      border-radius: 8px !important;\n      background: #ffffff !important;\n      font-size: 15px !important;\n      cursor: pointer !important;\n      transition: all 0.15s ease !important;\n      font-family: var(--pfd-font-family) !important;\n      color: #333333 !important;\n      margin: 4px !important;\n      height: auto !important;\n      box-shadow: none !important;\n      transform: none !important;\n      font-weight: 500 !important;\n      display: flex !important;\n      width: calc(100% - 8px) !important;\n      text-align: left !important;\n      justify-content: space-between !important;\n      align-items: center !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:hover {\n      background: #f3f4f6 !important;\n      transform: none !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:active {\n      transform: none !important;\n      box-shadow: none !important;\n      background: #e5e7eb !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected {\n      background: #f3f4f6 !important;\n      color: #333333 !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    /* Active state for dropdown button when custom option is selected */\n    .pfd-custom-dropdown.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .pfd-custom-options .pfd-checkmark {\n      color: #10b981 !important;\n      font-size: 12px !important;\n      font-weight: 600 !important;\n      margin-right: 8px !important;\n      display: inline-block !important;\n      opacity: 0 !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected .pfd-checkmark {\n      opacity: 1 !important;\n    }\n\n    .pfd-custom-options .pfd-option-text {\n      flex: 1 !important;\n      display: inline-block !important;\n    }\n\n    .pfd-custom-options .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 13px !important;\n      font-weight: 500 !important;\n      padding: 4px 8px !important;\n      border-radius: 4px !important;\n      margin-left: 16px !important;\n      display: inline-block !important;\n      flex-shrink: 0 !important;\n      line-height: 10px !important;\n    }\n\n    .pfd-custom-dropdown .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 11px !important;\n      font-weight: 500 !important;\n      padding: 2px 6px !important;\n      border-radius: 3px !important;\n      margin-left: 8px !important;\n      display: inline-block !important;\n      vertical-align: middle !important;\n      line-height: 1.2 !important;\n    }\n\n    .pfd-custom-notice {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-notice-content {\n      background: rgba(243, 244, 246, 0.5) !important; /* bg-muted/50 */\n      border: 1px solid #d1d5db !important; /* border-border */\n      border-radius: 8px !important; /* rounded-lg */\n      padding: 12px 16px !important; /* px-4 py-3 */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 12px !important; /* gap-3 */\n    }\n\n    .pfd-custom-notice-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      margin-top: 2px !important; /* mt-0.5 */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-notice-text {\n      font-size: 14px !important; /* text-sm */\n      margin: 0 !important;\n      line-height: 1.4 !important;\n      color: #374151 !important;\n    }\n\n    .pfd-custom-notice-text strong {\n      color: #111827 !important; /* text-foreground */\n      font-weight: 600 !important;\n    }\n\n    .pfd-custom-notice-highlight {\n      font-weight: 600 !important; /* font-semibold */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-option-info {\n      margin: 16px 0 20px 0 !important;\n      color: var(--pfd-muted-color) !important;\n    }\n\n    .pfd-info-content {\n      color: var(--pfd-muted-color) !important;\n      font-size: 14px !important; /* text-sm */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 8px !important; /* gap-2 */\n    }\n\n    .pfd-info-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      border-radius: 50% !important; /* rounded-full */\n      border: 1px solid rgba(107, 114, 128, 0.3) !important; /* border-muted-foreground/30 */\n      display: flex !important; /* flex */\n      align-items: center !important; /* items-center */\n      justify-content: center !important; /* justify-center */\n      font-size: 12px !important; /* text-xs */\n      margin-top: 2px !important; /* mt-0.5 */\n      font-weight: 500 !important;\n      background: #ffffff !important;\n    }\n\n    .pfd-info-text {\n      line-height: 1.4 !important;\n    }\n\n    .pfd-custom-option-content {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-option-content p {\n      margin: 0 !important;\n      font-size: 14px !important;\n      line-height: 1.4 !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right {\n      position: absolute !important;\n      right: 0 !important;\n      top: 0 !important;\n      font-size: 14px !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right .bold {\n      font-weight: 600 !important;\n      color: var(--pfd-text-color) !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__item.swatch-loading,\n    .pfd-standard-options .t4s-swatch__item.swatch-loading {\n      opacity: 0.6 !important;\n      pointer-events: none !important;\n    }\n\n    .t4s-swatch__item.swatch-error,\n    .pfd-standard-options .t4s-swatch__item.swatch-error {\n      background: #f5f5f5 !important;\n      color: var(--pfd-muted-color) !important;\n      border-color: #ddd !important;\n    }\n\n    .t4s-swatch__item:focus,\n    .pfd-standard-options .t4s-swatch__item:focus {\n      outline: 2px solid var(--pfd-border-color-selected) !important;\n      outline-offset: 2px !important;\n    }\n\n    @media (max-width: 1536px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n    }\n\n    @media (max-width: 1080px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n    }\n\n    @media (max-width: 768px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n\n      .pfd-split-selection {\n        flex-direction: column !important;\n        align-items: flex-start !important;\n        gap: 16px !important;\n      }\n\n      .pfd-standard-options {\n        width: 100% !important;\n      }\n\n      .pfd-or-separator {\n        display: none;\n      }\n\n      .pfd-custom-dropdown {\n        width: 100% !important;\n        min-width: 200px !important;\n      }\n\n      .pfd-or-separator {\n        align-self: center !important;\n        margin: 0 !important;\n      }\n    }\n\n    @media (max-width: 480px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n\n      .t4s-swatch__item,\n      .pfd-standard-options .t4s-swatch__item {\n        min-width: 45px !important;\n        height: 36px !important;\n        font-size: 13px !important;\n        padding: 0 8px !important;\n      }\n\n      .pfd-split-option .t4s-swatch__title--right {\n        position: static !important;\n        display: block !important;\n      }\n\n      .pfd-custom-dropdown {\n        height: 36px !important;\n        font-size: 13px !important;\n      }\n    }\n  }\n}\n\n/* ============================================\n   AWAITING RESTOCK BADGE\n   Glassmorphism badge positioned over swatch image\n   ============================================ */\n\n/* Ensure wrappers are positioned for badge anchoring */\n.t4s-swatch__btn-wrap,\n.t4s-swatch__item {\n  position: relative;\n}\n\ndiv[data-img-el] {\n  position: relative !important;\n}\n\n/* Badge base styles */\n.t4s-swatch__restock-badge {\n  position: absolute;\n  bottom: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n\n  background: rgba(0, 0, 0, 0.05);\n  backdrop-filter: blur(10px) saturate(1.2);\n  -webkit-backdrop-filter: blur(10px) saturate(1.2);\n\n  color: rgba(0, 0, 0, 0.85);\n\n  font-size: 8px;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  white-space: nowrap;\n  z-index: 2;\n  pointer-events: none;\n\n  border: 1px solid rgba(0, 0, 0, 0.08);\n\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);\n}\n\n/* ============================================\n   RESTOCK BADGE VISIBILITY CONTROL\n   Class-based toggle for JS compatibility\n   ============================================ */\n\n/* Hide badge when it's a direct child of the wrapper (not inside image container) */\n.t4s-swatch__btn-wrap > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Default: hide badge inside image container */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Show only when JS adds .is-visible class */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge.is-visible {\n  display: flex !important;\n  align-items: center;\n  justify-content: center;\n}\n\n/* For non-image swatches (length/text options): badge on the item itself */\n.t4s-swatch__item > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n.t4s-swatch__item > .t4s-swatch__restock-badge.is-visible {\n  display: block !important;\n}\n\n/* Content-aware contrast: Light background (dark hair) = dark text */\n[data-luminance=\"light\"] .t4s-swatch__restock-badge {\n  background: rgba(0, 0, 0, 0.05);\n  color: rgba(0, 0, 0, 0.85);\n  border-color: rgba(0, 0, 0, 0.1);\n}\n\n/* Content-aware contrast: Dark background (light hair) = light text */\n[data-luminance=\"dark\"] .t4s-swatch__restock-badge {\n  background: rgba(255, 255, 255, 0.05);\n  color: rgba(255, 255, 255, 0.95);\n  border-color: rgba(255, 255, 255, 0.15);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n}\n\n/* Subtle hover effect on out-of-stock swatches */\n.t4s-swatch__btn-wrap.is--out-of-stock:hover .t4s-swatch__restock-badge,\n.t4s-swatch__item.is--out-of-stock:hover .t4s-swatch__restock-badge {\n  backdrop-filter: blur(12px) saturate(1.3);\n  -webkit-backdrop-filter: blur(12px) saturate(1.3);\n  opacity: 0.9;\n}\n\n/* Keep full opacity on out-of-stock swatches for badge legibility */\n.t4s-swatch__btn-wrap.is--out-of-stock .t4s-swatch__item,\n.t4s-swatch__item.is--out-of-stock,\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el],\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el] img {\n  opacity: 1 !important;\n}\n\n/* ============================================\n   AVAILABLE LENGTHS TEXT\n   Shown below the swatch image, as a sibling in .t4s-swatch__btn-wrap\n   Displayed when a color is out of stock at the selected length\n   but available in other lengths\n   ============================================ */\n\n/* Base: hidden by default */\n.t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 2px;\n  /* Fallback before JS sets data-luminance: dark text with a white halo so it\n     reads on both light and dark swatch backgrounds without JS. */\n  color: rgba(20, 20, 20, 0.9);\n  text-shadow:\n    0 0 3px rgba(255, 255, 255, 0.9),\n    0 0 6px rgba(255, 255, 255, 0.7);\n  font-size: 9px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: normal;\n  word-break: break-word;\n  pointer-events: none;\n  line-height: 1.4;\n  max-width: 100%;\n  padding: 0 4px;\n}\n\n/* Show when Liquid SSR or JS adds .is-visible */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Direct child of btn-wrap: hidden by default, shown via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: attribute set on btn-wrap by JS luminance detection.\n   Once luminance is known, replace the halo text-shadow with a clean color. */\n.t4s-swatch__btn-wrap[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(20, 20, 20, 0.75);\n  text-shadow: none;\n}\n\n.t4s-swatch__btn-wrap[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.9);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);\n}\n\n/* Separator line above lengths text — visually separates it from the swatch image */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible::before {\n  content: '';\n  display: block;\n  width: 80%;\n  height: 1px;\n  background: currentColor;\n  opacity: 0.2;\n  margin: 0 auto 3px;\n}\n\n/* Reflow btn-wrap to column layout when lengths text is visible.\n   Scoped inside .pfd-override-wrapper to beat the nested align-items: center\n   !important on .t4s-swatch__btn-wrap from the base rule above.\n   .pfd-has-lengths is added by Liquid SSR and kept in sync by JS. */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex !important;\n  flex-direction: column !important;\n  align-items: stretch !important;\n  gap: 0 !important;\n}\n\n/* Image container stretches to fill card width in column layout */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > div[data-img-el],\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > div[data-img-el] {\n  width: 100% !important;\n}\n\n/* In column layout, reset badge position */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > .t4s-swatch__restock-badge,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > .t4s-swatch__restock-badge {\n  margin-left: 0 !important;\n  margin-top: 2px;\n}\n\n/* Tight spacing below the badge */\n.pfd-override-wrapper .t4s-swatch__btn-wrap.pfd-has-lengths > .t4s-swatch__available-lengths,\n.pfd-override-wrapper .t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) > .t4s-swatch__available-lengths {\n  margin-top: 3px;\n  text-align: center;\n  width: 100%;\n}\n",
              "reasoning": "Improve lengths text: larger font (9px), padding, separator line, stretch alignment in column layout, tighter gap."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772179862766",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Always run luminance detection — covers both newly-created badges and\n    // SSR-rendered badges whose image src may have just been updated by\n    // updateSwatchImages() after hydration.\n    if (imgContainer) {\n      detectSwatchLuminance(imgContainer, badge);\n    }\n\n    // Compute and show available standard lengths for this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n    // Hide available lengths — el IS the .t4s-swatch__btn-wrap\n    const lengthsEl = el.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    el.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n  // Prefer the explicit length option index injected by Liquid.\n  // Falls back to scanning all non-color options if not set.\n  const explicitLengthIdx = typeof window.__LENGTH_OPTION_INDEX__ === \"number\"\n    ? window.__LENGTH_OPTION_INDEX__\n    : -1;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Determine which option indices to report as \"available lengths\".\n  // If a specific length index was injected (option1 in most cases), use only that.\n  // Otherwise fall back to all non-color indices.\n  let targetIndices;\n  if (explicitLengthIdx >= 0 && explicitLengthIdx !== colorOptIdx) {\n    targetIndices = [explicitLengthIdx];\n  } else {\n    targetIndices = [];\n    for (let i = 0; i < optionCount; i++) {\n      if (i !== colorOptIdx) targetIndices.push(i);\n    }\n  }\n  if (targetIndices.length === 0) return;\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true;\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    // swatchEl IS the .t4s-swatch__btn-wrap — lengths span lives as its direct child\n    const existingEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n    return;\n  }\n\n  // Collect available values for the target (length) option indices,\n  // filtered to this color and excluding custom option values from the\n  // product metafield `custom.custom_values`.\n  const availableByOption = targetIndices.map((idx) => {\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Exclude values that are in the custom_values metafield list\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  // then fall back to locale-aware string sort for non-numeric values.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    const sorted = [...values].sort((a, b) => {\n      const na = parseFloat(a);\n      const nb = parseFloat(b);\n      if (!isNaN(na) && !isNaN(nb)) return na - nb;\n      return a.localeCompare(b);\n    });\n    if (targetIndices.length === 1) {\n      parts.push(sorted.join(\", \"));\n    } else {\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n    }\n  }\n\n  }\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      // Insert after the image container ([data-img-el]) so the order matches\n      // the Liquid-rendered DOM: image → lengths → label → nickname.\n      // Fall back to appendChild if no image container exists.\n      const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n      if (imgEl && imgEl.nextSibling) {\n        swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + parts.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n    swatchEl.classList.add(\"pfd-has-lengths\");\n\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  // The btn-wrap parent needs the attribute so the CSS cascade reaches\n  // the sibling .t4s-swatch__available-lengths element\n  const btnWrap = imgContainer.closest(\".t4s-swatch__btn-wrap\");\n\n  const applyLuminance = (result) => {\n    imgContainer.setAttribute(\"data-luminance\", result);\n    if (btnWrap) btnWrap.setAttribute(\"data-luminance\", result);\n  };\n\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    applyLuminance(\"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    applyLuminance(cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      luminanceCache.set(img.src, result);\n      applyLuminance(result);\n    } catch (e) {\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      applyLuminance(\"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      applyLuminance(\"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name.\n// Matches the full get_color set injected by Liquid as window.__COLOR_OPTION_NAMES__,\n// which includes \"color\", \"colors\", \"colour\", \"couleur\" plus any store-level additions.\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  const colorNames = window.__COLOR_OPTION_NAMES__ || [\"color\", \"colours\", \"couleur\", \"colour\", \"colors\"];\n  return colorNames.some((n) => normName(n) === optionName);\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Run luminance detection on SSR-rendered out-of-stock swatches.\n  // Badges and lengths text are rendered with is-visible by Liquid SSR, so\n  // we only need to set data-luminance on imgContainer + btnWrap so the\n  // contrast CSS cascade fires immediately — before hydration completes.\n  (function initLuminanceForSSRSwatches() {\n    const outOfStockWraps = root.querySelectorAll(\n      \".t4s-swatch__btn-wrap.is--out-of-stock\"\n    );\n    for (const wrap of outOfStockWraps) {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) continue;\n      // Ensure badge is visible (Liquid SSR now adds is-visible, but guard\n      // against older cached HTML that may not have it yet).\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      if (badge) badge.classList.add(\"is-visible\");\n      detectSwatchLuminance(imgContainer, badge);\n    }\n  })();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Sort available lengths numerically (14, 16, 18…) before display so the list reads in ascending order. Falls back to locale string sort for non-numeric values."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772179883926",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Always run luminance detection — covers both newly-created badges and\n    // SSR-rendered badges whose image src may have just been updated by\n    // updateSwatchImages() after hydration.\n    if (imgContainer) {\n      detectSwatchLuminance(imgContainer, badge);\n    }\n\n    // Compute and show available standard lengths for this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n    // Hide available lengths — el IS the .t4s-swatch__btn-wrap\n    const lengthsEl = el.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    el.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n  // Prefer the explicit length option index injected by Liquid.\n  // Falls back to scanning all non-color options if not set.\n  const explicitLengthIdx = typeof window.__LENGTH_OPTION_INDEX__ === \"number\"\n    ? window.__LENGTH_OPTION_INDEX__\n    : -1;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Determine which option indices to report as \"available lengths\".\n  // If a specific length index was injected (option1 in most cases), use only that.\n  // Otherwise fall back to all non-color indices.\n  let targetIndices;\n  if (explicitLengthIdx >= 0 && explicitLengthIdx !== colorOptIdx) {\n    targetIndices = [explicitLengthIdx];\n  } else {\n    targetIndices = [];\n    for (let i = 0; i < optionCount; i++) {\n      if (i !== colorOptIdx) targetIndices.push(i);\n    }\n  }\n  if (targetIndices.length === 0) return;\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true;\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    // swatchEl IS the .t4s-swatch__btn-wrap — lengths span lives as its direct child\n    const existingEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n    return;\n  }\n\n  // Collect available values for the target (length) option indices,\n  // filtered to this color and excluding custom option values from the\n  // product metafield `custom.custom_values`.\n  const availableByOption = targetIndices.map((idx) => {\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Exclude values that are in the custom_values metafield list\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  // then fall back to locale-aware string sort for non-numeric values.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    const sorted = [...values].sort((a, b) => {\n      const na = parseFloat(a);\n      const nb = parseFloat(b);\n      if (!isNaN(na) && !isNaN(nb)) return na - nb;\n      return a.localeCompare(b);\n    });\n    if (targetIndices.length === 1) {\n      parts.push(sorted.join(\", \"));\n    } else {\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n    }\n  }\n\n  }\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      // Insert after the image container ([data-img-el]) so the order matches\n      // the Liquid-rendered DOM: image → lengths → label → nickname.\n      // Fall back to appendChild if no image container exists.\n      const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n      if (imgEl && imgEl.nextSibling) {\n        swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + parts.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n    swatchEl.classList.add(\"pfd-has-lengths\");\n\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  // The btn-wrap parent needs the attribute so the CSS cascade reaches\n  // the sibling .t4s-swatch__available-lengths element\n  const btnWrap = imgContainer.closest(\".t4s-swatch__btn-wrap\");\n\n  const applyLuminance = (result) => {\n    imgContainer.setAttribute(\"data-luminance\", result);\n    if (btnWrap) btnWrap.setAttribute(\"data-luminance\", result);\n  };\n\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    applyLuminance(\"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    applyLuminance(cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      luminanceCache.set(img.src, result);\n      applyLuminance(result);\n    } catch (e) {\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      applyLuminance(\"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      applyLuminance(\"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name.\n// Matches the full get_color set injected by Liquid as window.__COLOR_OPTION_NAMES__,\n// which includes \"color\", \"colors\", \"colour\", \"couleur\" plus any store-level additions.\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  const colorNames = window.__COLOR_OPTION_NAMES__ || [\"color\", \"colours\", \"couleur\", \"colour\", \"colors\"];\n  return colorNames.some((n) => normName(n) === optionName);\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Run luminance detection on SSR-rendered out-of-stock swatches.\n  // Badges and lengths text are rendered with is-visible by Liquid SSR, so\n  // we only need to set data-luminance on imgContainer + btnWrap so the\n  // contrast CSS cascade fires immediately — before hydration completes.\n  (function initLuminanceForSSRSwatches() {\n    const outOfStockWraps = root.querySelectorAll(\n      \".t4s-swatch__btn-wrap.is--out-of-stock\"\n    );\n    for (const wrap of outOfStockWraps) {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) continue;\n      // Ensure badge is visible (Liquid SSR now adds is-visible, but guard\n      // against older cached HTML that may not have it yet).\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      if (badge) badge.classList.add(\"is-visible\");\n      detectSwatchLuminance(imgContainer, badge);\n    }\n  })();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Re-run luminance on all out-of-stock swatches now that images are loaded.\n    // updateSwatchImages() may have set new img.src values — clear the luminance\n    // cache so stale results don't carry over, then re-detect for each swatch.\n    luminanceCache.clear();\n    root.querySelectorAll(\".t4s-swatch__btn-wrap.is--out-of-stock\").forEach((wrap) => {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) return;\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      detectSwatchLuminance(imgContainer, badge);\n    });\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "After hydration updates swatch images, re-run luminance detection (with cache cleared) so the available-lengths text and restock badge get correct light/dark contrast based on the actual loaded image colors."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772179895040",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Always run luminance detection — covers both newly-created badges and\n    // SSR-rendered badges whose image src may have just been updated by\n    // updateSwatchImages() after hydration.\n    if (imgContainer) {\n      detectSwatchLuminance(imgContainer, badge);\n    }\n\n    // Compute and show available standard lengths for this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n    // Hide available lengths — el IS the .t4s-swatch__btn-wrap\n    const lengthsEl = el.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    el.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n  // Prefer the explicit length option index injected by Liquid.\n  // Falls back to scanning all non-color options if not set.\n  const explicitLengthIdx = typeof window.__LENGTH_OPTION_INDEX__ === \"number\"\n    ? window.__LENGTH_OPTION_INDEX__\n    : -1;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Determine which option indices to report as \"available lengths\".\n  // If a specific length index was injected (option1 in most cases), use only that.\n  // Otherwise fall back to all non-color indices.\n  let targetIndices;\n  if (explicitLengthIdx >= 0 && explicitLengthIdx !== colorOptIdx) {\n    targetIndices = [explicitLengthIdx];\n  } else {\n    targetIndices = [];\n    for (let i = 0; i < optionCount; i++) {\n      if (i !== colorOptIdx) targetIndices.push(i);\n    }\n  }\n  if (targetIndices.length === 0) return;\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true;\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    // swatchEl IS the .t4s-swatch__btn-wrap — lengths span lives as its direct child\n    const existingEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n    return;\n  }\n\n  // Collect available values for the target (length) option indices,\n  // filtered to this color and excluding custom option values from the\n  // product metafield `custom.custom_values`.\n  const availableByOption = targetIndices.map((idx) => {\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Exclude values that are in the custom_values metafield list\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  // then fall back to locale-aware string sort for non-numeric values.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    const sorted = [...values].sort((a, b) => {\n      const na = parseFloat(a);\n      const nb = parseFloat(b);\n      if (!isNaN(na) && !isNaN(nb)) return na - nb;\n      return a.localeCompare(b);\n    });\n    if (targetIndices.length === 1) {\n      parts.push(sorted.join(\", \"));\n    } else {\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n    }\n  }\n\n  }\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      // Insert after the image container ([data-img-el]) so the order matches\n      // the Liquid-rendered DOM: image → lengths → label → nickname.\n      // Fall back to appendChild if no image container exists.\n      const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n      if (imgEl && imgEl.nextSibling) {\n        swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + parts.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n    swatchEl.classList.add(\"pfd-has-lengths\");\n\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  // The btn-wrap parent needs the attribute so the CSS cascade reaches\n  // the sibling .t4s-swatch__available-lengths element\n  const btnWrap = imgContainer.closest(\".t4s-swatch__btn-wrap\");\n\n  const applyLuminance = (result) => {\n    imgContainer.setAttribute(\"data-luminance\", result);\n    if (btnWrap) btnWrap.setAttribute(\"data-luminance\", result);\n  };\n\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    applyLuminance(\"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    applyLuminance(cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      luminanceCache.set(img.src, result);\n      applyLuminance(result);\n    } catch (e) {\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      applyLuminance(\"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      applyLuminance(\"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name.\n// Matches the full get_color set injected by Liquid as window.__COLOR_OPTION_NAMES__,\n// which includes \"color\", \"colors\", \"colour\", \"couleur\" plus any store-level additions.\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  const colorNames = window.__COLOR_OPTION_NAMES__ || [\"color\", \"colours\", \"couleur\", \"colour\", \"colors\"];\n  return colorNames.some((n) => normName(n) === optionName);\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    // Handle load success — also re-run luminance so contrast is based on\n    // the actual loaded image, not the placeholder/previous state.\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n      // Re-detect luminance for this swatch's image container\n      const btnWrap = swatchItem.closest(\".t4s-swatch__btn-wrap\") || swatchItem;\n      if (btnWrap.classList.contains(\"is--out-of-stock\")) {\n        const imgContainer = btnWrap.querySelector(\"[data-img-el]\");\n        if (imgContainer) {\n          luminanceCache.delete(imgEl.src);\n          const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n          detectSwatchLuminance(imgContainer, badge);\n        }\n      }\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Run luminance detection on SSR-rendered out-of-stock swatches.\n  // Badges and lengths text are rendered with is-visible by Liquid SSR, so\n  // we only need to set data-luminance on imgContainer + btnWrap so the\n  // contrast CSS cascade fires immediately — before hydration completes.\n  (function initLuminanceForSSRSwatches() {\n    const outOfStockWraps = root.querySelectorAll(\n      \".t4s-swatch__btn-wrap.is--out-of-stock\"\n    );\n    for (const wrap of outOfStockWraps) {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) continue;\n      // Ensure badge is visible (Liquid SSR now adds is-visible, but guard\n      // against older cached HTML that may not have it yet).\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      if (badge) badge.classList.add(\"is-visible\");\n      detectSwatchLuminance(imgContainer, badge);\n    }\n  })();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Re-run luminance on all out-of-stock swatches now that images are loaded.\n    // updateSwatchImages() may have set new img.src values — clear the luminance\n    // cache so stale results don't carry over, then re-detect for each swatch.\n    luminanceCache.clear();\n    root.querySelectorAll(\".t4s-swatch__btn-wrap.is--out-of-stock\").forEach((wrap) => {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) return;\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      detectSwatchLuminance(imgContainer, badge);\n    });\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "When a swatch image finishes loading, re-run luminance detection so the restock badge and available-lengths text get correct light/dark contrast based on the real image content."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772179910858",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Always run luminance detection — covers both newly-created badges and\n    // SSR-rendered badges whose image src may have just been updated by\n    // updateSwatchImages() after hydration.\n    if (imgContainer) {\n      detectSwatchLuminance(imgContainer, badge);\n    }\n\n    // Compute and show available standard lengths for this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n    // Hide available lengths — el IS the .t4s-swatch__btn-wrap\n    const lengthsEl = el.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    el.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n  // Prefer the explicit length option index injected by Liquid.\n  // Falls back to scanning all non-color options if not set.\n  const explicitLengthIdx = typeof window.__LENGTH_OPTION_INDEX__ === \"number\"\n    ? window.__LENGTH_OPTION_INDEX__\n    : -1;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Determine which option indices to report as \"available lengths\".\n  // If a specific length index was injected (option1 in most cases), use only that.\n  // Otherwise fall back to all non-color indices.\n  let targetIndices;\n  if (explicitLengthIdx >= 0 && explicitLengthIdx !== colorOptIdx) {\n    targetIndices = [explicitLengthIdx];\n  } else {\n    targetIndices = [];\n    for (let i = 0; i < optionCount; i++) {\n      if (i !== colorOptIdx) targetIndices.push(i);\n    }\n  }\n  if (targetIndices.length === 0) return;\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true;\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    // swatchEl IS the .t4s-swatch__btn-wrap — lengths span lives as its direct child\n    const existingEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n    return;\n  }\n\n  // Collect available values for the target (length) option indices,\n  // filtered to this color and excluding custom option values from the\n  // product metafield `custom.custom_values`.\n  const availableByOption = targetIndices.map((idx) => {\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Exclude values that are in the custom_values metafield list\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build display text — sort values numerically (lengths like \"14\", \"16\"…)\n  // then fall back to locale-aware string sort for non-numeric values.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    const sorted = [...values].sort((a, b) => {\n      const na = parseFloat(a);\n      const nb = parseFloat(b);\n      if (!isNaN(na) && !isNaN(nb)) return na - nb;\n      return a.localeCompare(b);\n    });\n    if (targetIndices.length === 1) {\n      parts.push(sorted.join(\", \"));\n    } else {\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${sorted.join(\", \")}` : sorted.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n\n  // swatchEl IS the .t4s-swatch__btn-wrap (data-swatch-item is on the btn-wrap div)\n  let lengthsEl = swatchEl.querySelector(\":scope > .t4s-swatch__available-lengths\");\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      // Insert after the image container ([data-img-el]) so the order matches\n      // the Liquid-rendered DOM: image → lengths → label → nickname.\n      // Fall back to appendChild if no image container exists.\n      const imgEl = swatchEl.querySelector(\":scope > [data-img-el]\");\n      if (imgEl && imgEl.nextSibling) {\n        swatchEl.insertBefore(lengthsEl, imgEl.nextSibling);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + parts.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n    swatchEl.classList.add(\"pfd-has-lengths\");\n\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    swatchEl.classList.remove(\"pfd-has-lengths\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  // The btn-wrap parent needs the attribute so the CSS cascade reaches\n  // the sibling .t4s-swatch__available-lengths element\n  const btnWrap = imgContainer.closest(\".t4s-swatch__btn-wrap\");\n\n  const applyLuminance = (result) => {\n    imgContainer.setAttribute(\"data-luminance\", result);\n    if (btnWrap) btnWrap.setAttribute(\"data-luminance\", result);\n  };\n\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    applyLuminance(\"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    applyLuminance(cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      luminanceCache.set(img.src, result);\n      applyLuminance(result);\n    } catch (e) {\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      applyLuminance(\"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      applyLuminance(\"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name.\n// Matches the full get_color set injected by Liquid as window.__COLOR_OPTION_NAMES__,\n// which includes \"color\", \"colors\", \"colour\", \"couleur\" plus any store-level additions.\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  const colorNames = window.__COLOR_OPTION_NAMES__ || [\"color\", \"colours\", \"couleur\", \"colour\", \"colors\"];\n  return colorNames.some((n) => normName(n) === optionName);\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    // Handle load success — also re-run luminance so contrast is based on\n    // the actual loaded image, not the placeholder/previous state.\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n      // Re-detect luminance for this swatch's image container\n      const btnWrap = swatchItem.closest(\".t4s-swatch__btn-wrap\") || swatchItem;\n      if (btnWrap.classList.contains(\"is--out-of-stock\")) {\n        const imgContainer = btnWrap.querySelector(\"[data-img-el]\");\n        if (imgContainer) {\n          luminanceCache.delete(imgEl.src);\n          const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n          detectSwatchLuminance(imgContainer, badge);\n        }\n      }\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Run luminance detection on SSR-rendered out-of-stock swatches.\n  // Badges and lengths text are rendered with is-visible by Liquid SSR, so\n  // we only need to set data-luminance on imgContainer + btnWrap so the\n  // contrast CSS cascade fires immediately — before hydration completes.\n  (function initLuminanceForSSRSwatches() {\n    const outOfStockWraps = root.querySelectorAll(\n      \".t4s-swatch__btn-wrap.is--out-of-stock\"\n    );\n    for (const wrap of outOfStockWraps) {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) continue;\n      // Ensure badge is visible (Liquid SSR now adds is-visible, but guard\n      // against older cached HTML that may not have it yet).\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      if (badge) badge.classList.add(\"is-visible\");\n      detectSwatchLuminance(imgContainer, badge);\n    }\n  })();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Re-run luminance on all out-of-stock swatches now that images are loaded.\n    // updateSwatchImages() may have set new img.src values — clear the luminance\n    // cache so stale results don't carry over, then re-detect for each swatch.\n    luminanceCache.clear();\n    root.querySelectorAll(\".t4s-swatch__btn-wrap.is--out-of-stock\").forEach((wrap) => {\n      const imgContainer = wrap.querySelector(\"[data-img-el]\");\n      if (!imgContainer) return;\n      const badge = imgContainer.querySelector(\".t4s-swatch__restock-badge\");\n      detectSwatchLuminance(imgContainer, badge);\n    });\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Remove the stray closing brace on line 818 that was left over from the original code block, which was causing the linter's extra-closing-brace error."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          }
        ],
        "reasoningBlocks": [],
        "responseText": "",
        "outcome": {
          "status": "applied",
          "changedFiles": 5,
          "changeSummary": "product-form-dynamic.css: Improve lengths text: larger font (9px), padding, separator line, stretch alignment in column layout, tighter gap.\nproduct-form-dynamic.js: Sort available lengths numerically (14, 16, 18…) before display so the list reads in ascending order. Falls back to locale string sort for non-numeric values.",
          "validationIssues": [
            {
              "gate": "theme_check",
              "errors": [
                "templates/page.ecom-deadfest2025.json — Invalid JSON in template file",
                "templates/article.portfolio.json — Invalid JSON in template file",
                "templates/page.ecom-deaducation-live-phoenix.json — Invalid JSON in template file",
                "templates/index.ecom-preview-home.json — Invalid JSON in template file",
                "templates/index.ecom-preview-page.json — Invalid JSON in template file"
              ],
              "changesKept": true
            }
          ]
        },
        "metrics": {
          "totalToolCalls": 31,
          "editToolCalls": 10,
          "readToolCalls": 19,
          "searchToolCalls": 0,
          "elapsedMs": 241625,
          "costCents": 418,
          "inputTokens": 1346505,
          "outputTokens": 9275
        }
      },
      "analysis": {
        "diagnosis": {
          "summary": "Agent successfully completed the task (5 files changed, 31 tool calls, 242s). The implementation correctly added 'Awaiting Restock' badge with available lengths list across all three layers (Liquid, CSS, JS). However, the execution had two significant issues: (1) 5 trailing `propose_code_edit` calls all failed silently with no result, indicating a tool executor or response handling failure, and (2) agent reasoning was not captured in the transcript, suggesting context or logging gaps.",
          "rootCause": "The `propose_code_edit` tool (calls 27-31) appears to be either deprecated, misconfigured, or returning empty responses that aren't being logged. The tool executor in `lib/agents/tools/v2-tool-executor.ts` either doesn't handle this tool or fails to capture its output. Additionally, agent reasoning blocks were not persisted to the transcript, indicating a potential issue in the coordinator's logging or context management of intermediate thoughts.",
          "agentBehavior": "Agent took a hybrid approach: (1) read files to understand structure (10 reads), (2) executed 5 successful `edit_lines` operations directly on CSS and JS files, (3) ran 2 `check_lint` validations, (4) attempted 5 `propose_code_edit` calls that failed silently. The agent did not retry failed `propose_code_edit` calls or escalate the failure, instead continuing and completing the task via direct edits. The agent's reasoning was not captured in the transcript despite the coordinator being capable of logging it."
        },
        "recommendations": [
          {
            "priority": "critical",
            "category": "tools",
            "title": "Fix propose_code_edit tool executor and response handling",
            "description": "The `propose_code_edit` tool is returning no result (calls 27-31 all show '[ERROR] -> (no result received)'). This indicates either the tool is not implemented in the executor, returns undefined/null, or the response parsing fails. The coordinator must either remove this tool from the schema if it's deprecated, or fix the executor to properly return structured responses.",
            "targetFile": "lib/agents/tools/v2-tool-executor.ts",
            "targetArea": "run_specialist() or tool dispatch logic for propose_code_edit",
            "suggestedChange": "Add explicit handling for propose_code_edit: (1) Verify the tool is implemented and callable, (2) Ensure response always returns {success: boolean, message: string, changes?: object}, (3) Add error logging if tool fails, (4) Consider removing from tool definitions if truly deprecated. Example: if (toolName === 'propose_code_edit') { const result = await callProposalEngine(...); return result || {success: false, message: 'Tool not implemented'}; }"
          },
          {
            "priority": "high",
            "category": "coordinator",
            "title": "Capture and persist agent reasoning blocks to transcript",
            "description": "The 'Agent Reasoning (last 5 blocks)' section shows '(no reasoning captured)' despite the agent running 31 tool calls over 242 seconds. The coordinator should be logging intermediate reasoning steps from the LLM's think phase. This is critical for transparency and debugging.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Main loop iteration block, after LLM response parsing",
            "suggestedChange": "After each LLM response, extract and store the reasoning/thinking content before tool execution. Example: const reasoning = response.content.filter(block => block.type === 'thinking').map(b => b.thinking).join('\\n'); transcript.reasoningBlocks.push({iteration: i, reasoning, timestamp: Date.now()});"
          },
          {
            "priority": "high",
            "category": "validation",
            "title": "Add post-edit validation for silent tool failures",
            "description": "When a tool returns no result (as seen in calls 27-31), the coordinator should detect this and either retry, escalate, or log a warning. Currently, failed `propose_code_edit` calls are silently ignored, which masks problems.",
            "targetFile": "lib/agents/orchestration-policy.ts",
            "targetArea": "Validation gate for tool responses",
            "suggestedChange": "Add a validation rule: if (toolResult === null || toolResult === undefined) { if (tool.critical) { throw new Error(`Critical tool ${toolName} returned no result`); } else { log.warn(`Tool ${toolName} returned empty result on iteration ${iteration}`); } }"
          },
          {
            "priority": "high",
            "category": "tools",
            "title": "Consolidate edit_lines and propose_code_edit workflows",
            "description": "The agent successfully used `edit_lines` directly (calls 7, 16, 19, 21, 24) but then attempted `propose_code_edit` (calls 27-31) which failed. These tools appear to have overlapping intent. The tool definitions should clarify when to use each, or consolidate into a single edit tool.",
            "targetFile": "lib/agents/tools/v2-tool-definitions.ts",
            "targetArea": "Tool schema definitions for edit_lines and propose_code_edit",
            "suggestedChange": "Either: (1) Remove propose_code_edit and use only edit_lines, or (2) Define clear separation: edit_lines for direct modifications, propose_code_edit for review-gated changes. Update the PM prompt to specify which tool to use in which context."
          },
          {
            "priority": "medium",
            "category": "prompt",
            "title": "Clarify multi-layer implementation strategy in PM prompt",
            "description": "The agent successfully implemented all three layers (Liquid, CSS, JS) but did not explicitly document the strategy of doing so in one pass. The PM prompt should provide clearer guidance on when to use `run_specialist` for multi-layer tasks vs. sequential edits.",
            "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
            "targetArea": "Tool usage instructions section",
            "suggestedChange": "Add guidance: 'For multi-layer requests (markup + style + behavior), prefer direct edit_lines calls in sequence over run_specialist when all files are in scope and changes are interdependent. Use run_specialist only when a single file requires deep analysis or when layers are loosely coupled.'"
          },
          {
            "priority": "medium",
            "category": "coordinator",
            "title": "Track and report tool success/failure metrics per iteration",
            "description": "The transcript shows tool calls but does not clearly distinguish between successful and failed operations. Calls 27-31 all show '[ERROR]' but the agent continued without escalation. The transcript should include a summary of success rates and failure patterns.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Transcript generation / summary block at end of execution",
            "suggestedChange": "After final iteration, add: { toolMetrics: { total: 31, successful: 26, failed: 5, failureRate: '16%', failedTools: ['propose_code_edit'] }, stagnationDetected: false, iterationsFinal: N }"
          },
          {
            "priority": "medium",
            "category": "context",
            "title": "Validate CSS and JS changes against design tokens and style profile",
            "description": "The agent modified CSS (lines 726-801) and JS (lines 799-808, 1946-1960, 1122-1125) but the decision log shows 'cssPreloaded=false' and 'designTokenCount=0'. This suggests the style profile was not fully loaded, yet changes were made without validation against design tokens.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Context building phase, style profile loading",
            "suggestedChange": "Before executing edits on CSS files, ensure style profile is fully loaded: if (fileType === 'css' && !context.styleProfile.isLoaded) { await loadStyleProfile(); } Validate new CSS properties against design tokens before edit_lines execution."
          }
        ]
      }
    }
  ],
  "summary": {
    "passRate": "0/1 (0%)",
    "avgToolCalls": 31,
    "avgTimeSeconds": 242,
    "totalCostCents": 418,
    "failureReasons": [
      "Missing required file edits: snippets/product-form-dynamic.liquid"
    ]
  },
  "aggregateAnalysis": {
    "diagnosis": {
      "summary": "Single run completed successfully with full implementation across 3 layers (Liquid, CSS, JS), but experienced 5 consecutive propose_code_edit tool failures at the end without blocking completion. The agent recovered from these failures, suggesting either transient API issues or incomplete result handling rather than fundamental logic failure.",
      "rootCause": "propose_code_edit tool returned no result in 5 consecutive calls (likely late-stage refinement attempts), but the agent had already successfully applied core changes via edit_lines before the failures occurred. Root cause is either: (1) Tool executor not properly handling propose_code_edit responses, (2) Transient API/model failures on refinement phase, or (3) Missing error recovery logic for propose_code_edit specifically.",
      "agentBehavior": "Agent executed a methodical read→understand→edit→verify workflow: read product-form-dynamic.liquid/css/js and related files (11 read operations), identified correct insertion points and logic requirements, applied 4 successful edit_lines operations to implement core functionality, then attempted 5 propose_code_edit refinements (all failed with no result). Despite tool failures, agent marked run as applied because core implementation succeeded. This suggests propose_code_edit is used for polish/validation rather than critical changes."
    },
    "patterns": {
      "consistentFailureMode": null,
      "intermittentIssues": [
        "propose_code_edit returns no result (5x in sequence) - suggests either model timeout, response parsing failure, or tool executor bug specific to this tool",
        "No error propagation visible - agent continued despite failures, implying graceful degradation but possible silent failure mode"
      ],
      "toolUsageAntiPatterns": [
        "5 consecutive propose_code_edit calls without intervening reads/validation - suggests agent was attempting iterative refinement without checking intermediate results",
        "Multiple read_lines on same file (product-form-dynamic.liquid read 3x, css read 2x, js read 2x) before any edits - inefficient context gathering, though understandable for complex multi-layer task",
        "check_lint called twice in sequence (no intervening edits) - redundant validation",
        "propose_code_edit called after successful edit_lines operations - suggests agent treating propose_code_edit as refinement rather than primary edit path, which is correct but late-stage failures indicate this tool may be unreliable"
      ],
      "contextGaps": [
        "No explicit read of product metafield schema or custom_values structure before implementing filter logic - agent inferred requirements from task description rather than inspecting actual data structure",
        "No read of existing variant option1 handling or length enumeration patterns in codebase - agent implemented from first principles",
        "No read of color contrast testing utilities or accessibility patterns already in codebase - agent implemented contrast logic without reference to existing standards"
      ]
    },
    "recommendations": [
      {
        "priority": "critical",
        "category": "tools",
        "title": "Fix propose_code_edit result handling and timeout logic",
        "description": "The propose_code_edit tool failed 5x consecutively with 'no result received'. This indicates either: (1) Tool executor not properly awaiting/parsing responses, (2) Model timeouts on complex code proposals, or (3) Response format mismatch. Investigate v2-tool-executor.ts run_specialist/propose_code_edit branch for missing error handling, timeout configuration, or response validation.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "run_specialist execution path for propose_code_edit, response parsing, timeout handling",
        "suggestedChange": "Add explicit timeout configuration for propose_code_edit (separate from edit_lines), implement detailed error logging showing raw response/error, add retry logic with exponential backoff for transient failures, validate response format before returning to coordinator. Consider splitting propose_code_edit into propose (get suggestion) and validate (check result) as separate tool calls."
      },
      {
        "priority": "high",
        "category": "coordinator",
        "title": "Implement tool-specific error recovery and stagnation detection",
        "description": "When a tool fails 5x in sequence, coordinator should detect stagnation and either: (1) Switch to alternative tool, (2) Backtrack to last successful state, or (3) Escalate to human review. Currently agent silently continues despite propose_code_edit failures. Add stagnation detection that triggers after 3 consecutive failures of same tool, with strategy to fall back to edit_lines or skip refinement phase.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Main loop iteration tracking, tool failure counting, stagnation detection logic",
        "suggestedChange": "Track consecutive failures per tool (not global). If any tool fails 3x consecutively, add decision point: if tool is propose_code_edit and core edits succeeded, skip remaining proposals; if tool is critical (edit_lines), escalate to review. Log these decisions clearly."
      },
      {
        "priority": "high",
        "category": "prompt",
        "title": "Clarify when to use propose_code_edit vs edit_lines in PM prompt",
        "description": "Agent successfully used edit_lines for core changes but then attempted 5 propose_code_edit calls for refinement. The PM prompt should explicitly state: propose_code_edit is for code review/suggestion phase only, not primary implementation. If core implementation succeeded via edit_lines, propose_code_edit failures should not block completion.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Tool usage instructions section, propose_code_edit description",
        "suggestedChange": "Add guidance: 'Use edit_lines for direct file modifications. Use propose_code_edit only for code review, refactoring suggestions, or validation after successful edits. If propose_code_edit fails and core implementation is complete, proceed without it.' Include examples of when each tool is appropriate."
      },
      {
        "priority": "high",
        "category": "validation",
        "title": "Add post-edit verification before refinement phase",
        "description": "Agent applied 4 edit_lines successfully, then attempted 5 propose_code_edit refinements. Add validation gate between core implementation and refinement: verify edited files pass linting and basic syntax checks before attempting propose_code_edit. This prevents refinement attempts on broken code.",
        "targetFile": "lib/agents/orchestration-policy.ts",
        "targetArea": "Context gates, validation rules before refinement phase",
        "suggestedChange": "Add rule: 'After successful edit_lines operations, run check_lint on all modified files. Only proceed to propose_code_edit refinement if lint passes. If lint fails, attempt fix via edit_lines before refinement.'"
      },
      {
        "priority": "medium",
        "category": "context",
        "title": "Optimize file reading pattern for multi-layer tasks",
        "description": "Agent read product-form-dynamic.liquid 3x, css 2x, js 2x before making edits. For complex multi-file tasks, implement smarter read strategy: read entire file once, extract regions of interest, then edit targeted regions. This reduces token usage and iteration count.",
        "targetFile": "lib/agents/scout/structural-scout.ts",
        "targetArea": "Scout brief generation for multi-layer tasks, file targeting logic",
        "suggestedChange": "When task spans multiple files (Liquid + CSS + JS), generate scout brief that identifies all target regions upfront (via grep or extract_region) and reads each file only once. Return map of file→regions to edit, preventing redundant reads."
      },
      {
        "priority": "medium",
        "category": "context",
        "title": "Pre-load data structure context for variant/metafield operations",
        "description": "Agent implemented variant option1 filtering and metafield exclusion logic without explicitly reading the data structure definitions. For tasks involving variant options or metafields, automatically read schema/type definitions and existing usage patterns.",
        "targetFile": "lib/agents/theme-map/lookup.ts",
        "targetArea": "Theme map index, data structure lookups",
        "suggestedChange": "Add theme map entries for 'variant_option_schema', 'metafield_definitions', 'custom_values_structure'. When task mentions 'variant option1' or 'metafield', automatically include these in context via scout brief."
      },
      {
        "priority": "medium",
        "category": "tools",
        "title": "Add result validation to check_lint tool",
        "description": "Agent called check_lint twice consecutively with no intervening edits. check_lint should either: (1) Return early if no files changed since last check, or (2) Include in response what changed. This prevents redundant validation.",
        "targetFile": "lib/agents/tools/v2-tool-definitions.ts",
        "targetArea": "check_lint tool definition and response schema",
        "suggestedChange": "Modify check_lint response to include 'filesChanged' array and 'isCached' flag. If isCached=true, agent should skip redundant checks. Alternatively, add 'check_lint_since_last_edit' parameter to prevent duplicate calls."
      },
      {
        "priority": "low",
        "category": "prompt",
        "title": "Add Shopify color contrast and accessibility patterns to knowledge base",
        "description": "Agent implemented contrast logic without referencing existing accessibility patterns in codebase. Enrich PM prompt with guidance on Shopify theme accessibility standards, contrast ratio requirements, and existing utility classes for background-aware text.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Shopify knowledge section, accessibility guidelines",
        "suggestedChange": "Add section: 'For text over images/swatches: use CSS filters, mix-blend-mode, or text-shadow for contrast. Reference assets/accessibility-utils.css for existing contrast patterns. WCAG AA requires 4.5:1 for normal text. Test with both light and dark swatch backgrounds.'"
      }
    ]
  }
}