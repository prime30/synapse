{
  "timestamp": "2026-02-27T05:26:39.933Z",
  "projectId": "838e7498-6dc5-4268-9fcd-e6f6148f65ad",
  "scenario": "restock-badge-lengths",
  "prompt": "Add available lengths text under the \"Awaiting Restock\" badge when a color is out of stock in the currently selected length but available in other lengths. Show which non-color options are still available for that color.",
  "totalRuns": 1,
  "results": [
    {
      "run": 1,
      "passed": true,
      "reason": "Applied 3 file(s) in 19 tool calls",
      "metrics": {
        "totalToolCalls": 19,
        "editToolCalls": 6,
        "readToolCalls": 10,
        "searchToolCalls": 1,
        "elapsedMs": 148758,
        "costCents": 29,
        "inputTokens": 75496,
        "outputTokens": 4173
      },
      "tier": "COMPLEX",
      "strategy": "GOD_MODE",
      "changedFiles": [],
      "transcript": {
        "runId": "run-1",
        "scenario": "restock-badge-lengths",
        "decisions": [
          {
            "phase": "analyzing",
            "label": "Loading context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Context ready",
            "detail": "606 files, 5 prefs",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Classifying request...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Preparing file context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building structural brief...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Starting agent...",
            "timestamp": 0
          },
          {
            "phase": "strategy",
            "label": "Strategy: GOD_MODE",
            "detail": "strategy=GOD_MODE, tier=COMPLEX",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "COMPLEX tier — GOD_MODE strategy — claude-sonnet-4-6",
            "detail": "routingTier=COMPLEX, strategy=GOD_MODE",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Style profile loaded",
            "detail": "styleProfileRules=8, designTokenCount=0, patternConflictResolutions=0, referenceSectionsLoaded=0, cssPreloaded=false, snippetConsumers=0",
            "timestamp": 0
          }
        ],
        "toolSequence": [
          {
            "name": "read_lines",
            "id": "toolu_01VsKS4gFAAQHz3yVvhYmKLj",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 699,
                  "endLine": 769
                },
                {
                  "startLine": 837,
                  "endLine": 900
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01RritS7Hgf7NK7b67o74UWV",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 900,
                  "endLine": 1000
                },
                {
                  "startLine": 1420,
                  "endLine": 1581
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01BWqgmeGWD5tHmLsz7tKftF",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 175,
                  "endLine": 260
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01NjkrvQD1KsTuH3pAzzfSLa",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 744,
                  "endLine": 769
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01N56Pq8uc21xtmtcdEGQRxU",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 173,
                  "endLine": 230
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01Df5YN4GGtYurBxGrrM5hfx",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 651,
                  "endLine": 705
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01UK4gDu2cqpLeyaALPKYFzo",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 742,
                  "endLine": 775
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_01Wf8EmsPmt4QFkXyPtyXY93",
            "input": {
              "fileName": "assets/product-form-dynamic.css"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_01CeY58D7iWdM6VT82qA7es5",
            "input": {
              "fileName": "assets/product-form-dynamic.js"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_016fvb1z23z9WStpXpMfPFvF",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 173,
                  "endLine": 245
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "semantic_search",
            "id": "toolu_01KrmaaDxAKT8YztuVrreCvH",
            "input": {
              "query": "updateAvailableLengths restock badge show hide setSoldOut color swatch",
              "limit": 5
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "extract_region",
            "id": "toolu_01KtQpp6vsjkRWMokoWgH32x",
            "input": {
              "fileId": "assets/product-form-dynamic.js",
              "hint": "setSoldOut",
              "contextLines": 6
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "extract_region",
            "id": "toolu_011AK5D87oFZdL4UHFgqrJrL",
            "input": {
              "fileId": "assets/product-form-dynamic.js",
              "hint": "getSwatchItems",
              "contextLines": 4
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772169870552",
            "input": {
              "filePath": "product-form-dynamic.css",
              "newContent": "/* Hidden state for unavailable colors when custom option is selected */\n.t4s-swatch__btn-wrap.pfd-hidden-custom {\n  display: none !important;\n}\n\n.pfd-override-wrapper {\n\n  --pfd-border-color: rgb(230, 230, 230);\n  --pfd-border-color-selected: rgb(20, 20, 20);\n  --pfd-background: #ffffff;\n  --pfd-text-color: rgb(20, 20, 20);\n  --pfd-muted-color: rgb(115, 115, 115);\n\n  .pfd-custom-wrapper {\n    font-family: 'AeonikPro-Medium' !important;\n\n    .bold {\n      font-weight: bold !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__title {\n      display: flex !important;\n      flex-direction: row !important;\n      justify-content: space-between !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n      font-size: 14px !important;\n      text-transform: none !important;\n      color: var(--pfd-muted-color) !important;\n\n      .t4s-swatch__title--left span {\n        color: var(--pfd-text-color) !important;\n      }\n\n      .t4s-swatch__title--right {\n        color: var(--pfd-text-color) !important;\n        text-align: right !important;\n      }\n    }\n\n    .t4s-swatch__title--color {\n      color: var(--pfd-text-color) !important;\n      font-size: 14px !important;\n    }\n\n    .t4s-swatch__list {\n      gap: 8px !important;\n      margin: 0 !important;\n    }\n\n/* Awaiting Restock Badge - Glassmorphism with Content-Aware Contrast */\n.t4s-swatch__btn-wrap,\n.t4s-swatch__item {\n  position: relative;\n}\n\n/* Ensure image container is positioned for badge anchoring */\ndiv[data-img-el] {\n  position: relative !important;\n}\n\n.t4s-swatch__restock-badge {\n  position: absolute;\n  bottom: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n\n  /* Caustic glass effect - 5% opacity with blur */\n  background: rgba(0, 0, 0, 0.05);\n  backdrop-filter: blur(10px) saturate(1.2);\n  -webkit-backdrop-filter: blur(10px) saturate(1.2);\n\n  /* Default: dark text for light backgrounds */\n  color: rgba(0, 0, 0, 0.85);\n\n  font-size: 8px;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  white-space: nowrap;\n  z-index: 2;\n  pointer-events: none;\n\n  /* Subtle border for definition */\n  border: 1px solid rgba(0, 0, 0, 0.08);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);\n}\n/* Ensure image container is positioned for badge anchoring */\ndiv[data-img-el] {\n  position: relative !important;\n}\n\n.t4s-swatch__restock-badge {\n  position: absolute;\n  bottom: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n\n  /* Caustic glass effect - 5% opacity with blur */\n  background: rgba(0, 0, 0, 0.05);\n  backdrop-filter: blur(10px) saturate(1.2);\n  -webkit-backdrop-filter: blur(10px) saturate(1.2);\n\n  /* Default: dark text for light backgrounds */\n  color: rgba(0, 0, 0, 0.85);\n\n  font-size: 8px;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  white-space: nowrap;\n  z-index: 2;\n  pointer-events: none;\n\n  /* Subtle border for definition */\n  border: 1px solid rgba(0, 0, 0, 0.08);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);\n}\n\n/* ============================================\n   RESTOCK BADGE VISIBILITY CONTROL\n   Class-based toggle for JS compatibility\n   INSERT THESE RULES HERE ↓\n   ============================================ */\n\n/* Hide badge outside image container (direct child of wrapper) */\n.t4s-swatch__btn-wrap > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Default: hide badge inside image container */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Show only when JS adds .is-visible class */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge.is-visible {\n  display: flex !important;\n}\n\n/* For non-image swatches (length/text): also class-based */\n.t4s-swatch__item > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n.t4s-swatch__item > .t4s-swatch__restock-badge.is-visible {\n  display: block !important;\n}\n\n/* ============================================\n   END VISIBILITY CONTROL\n   ============================================ */\n/* Content-aware contrast: Light background (dark hair) = dark text */\n[data-luminance=\"light\"] .t4s-swatch__restock-badge {\n  background: rgba(0, 0, 0, 0.05);\n  color: rgba(0, 0, 0, 0.85);\n  border-color: rgba(0, 0, 0, 0.1);\n}\n\n/* Content-aware contrast: Dark background (light hair) = light text */\n[data-luminance=\"dark\"] .t4s-swatch__restock-badge {\n  background: rgba(255, 255, 255, 0.05);\n  color: rgba(255, 255, 255, 0.95);\n  border-color: rgba(255, 255, 255, 0.15);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS TEXT\n   Shown below the swatch image, under the restock badge\n   ============================================ */\n.t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 3px;\n\n  /* Default: muted dark text */\n  color: rgba(0, 0, 0, 0.65);\n\n  font-size: 7px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: nowrap;\n  pointer-events: none;\n  line-height: 1.2;\n}\n\n/* Show when JS adds .is-visible class */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: Light background = dark text */\n[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(0, 0, 0, 0.65);\n}\n\n/* Content-aware contrast: Dark background = light text */\n[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.85);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS VISIBILITY CONTROL\n   Element lives as direct child of .t4s-swatch__btn-wrap\n   ============================================ */\n\n/* Hide by default — JS controls visibility via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n/* Show when JS adds .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Ensure btn-wrap stacks vertically so text sits below the swatch */\n.t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n/* Compact version for circular/small swatches */\n.t4s-swatch__restock-badge--compact {\n  font-size: 7px;\n  padding: 3px 6px;\n}\n\n/* Keep full opacity on out-of-stock swatches for badge legibility */\n.t4s-swatch__btn-wrap.is--out-of-stock .t4s-swatch__item,\n.t4s-swatch__item.is--out-of-stock,\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el],\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el] img {\n  opacity: 1 !important;\n}\n\n/* Subtle hover effect */\n.t4s-swatch__btn-wrap.is--out-of-stock:hover .t4s-swatch__restock-badge,\n.t4s-swatch__item.is--out-of-stock:hover .t4s-swatch__restock-badge {\n  backdrop-filter: blur(12px) saturate(1.3);\n  -webkit-backdrop-filter: blur(12px) saturate(1.3);\n}\n/* Compact version for circular/small swatches */\n.t4s-swatch__restock-badge--compact {\n  font-size: 7px;\n  padding: 2px 4px;\n}\n\n/* Keep full opacity on out-of-stock swatches */\n.t4s-swatch__btn-wrap.is--out-of-stock .t4s-swatch__item,\n.t4s-swatch__item.is--out-of-stock {\n  opacity: 1; /* Override any default dimming */\n}\n\n/* Optional: subtle border indicator */\n.t4s-swatch__btn-wrap.is--out-of-stock,\n.t4s-swatch__item.is--out-of-stock {\n  border-color: rgba(0, 0, 0, 0.15);\n}\n\n/* Ensure badge doesn't interfere with selection */\n.t4s-swatch__btn-wrap.is--out-of-stock:hover .t4s-swatch__restock-badge,\n.t4s-swatch__item.is--out-of-stock:hover .t4s-swatch__restock-badge {\n  opacity: 0.9;\n}\n\n/* Color nickname styling - displays under swatch label */\n.t4s-swatch__nickname {\n  display: block;\n  font-size: 12px;\n  font-weight: 400;\n  color: var(--color-text-muted, #888);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.3;\n}\n\n/* Ensure proper spacing in swatch wrapper */\n.t4s-swatch__btn-wrap {\n  text-align: center;\n}\n\n/* Adjust for label + nickname stacking */\n.t4s-swatch__btn-wrap .t4s-swatch__label {\n  display: block;\n  font-weight: 600;\n}\n\n    .t4s-swatch__item,\n    .pfd-standard-options .t4s-swatch__item {\n      font-weight: 600 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: center !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      user-select: none !important;\n    }\n\n    .t4s-swatch__item::before {\n      content: none !important;\n    }\n\n    .t4s-swatch__item:hover,\n    .pfd-standard-options .t4s-swatch__item:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n      transform: translateY(-2px) !important;\n    }\n\n    .t4s-swatch__item:active,\n    .pfd-standard-options .t4s-swatch__item:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .t4s-swatch__item.is--selected,\n    .pfd-standard-options .t4s-swatch__item.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .t4s-swatch__item.is--soldout,\n    .pfd-standard-options .t4s-swatch__item.is--soldout {\n      opacity: 0.7 !important;\n      /*background: #f5f5f5 !important;*/\n      color: var(--pfd-muted-color) !important;\n      cursor: pointer !important;\n    }\n.color-info-accordion-text{\n  font-family: 'AeonikPro-Medium'\n}\n    .t4s-swatch__btn-wrap {\n      font-weight: 600 !important;\n      height: auto !important;\n      width: calc(25% - 6px) !important;\n      margin: 0 !important;\n      padding: 8px 8px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 12px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: flex-start !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      flex-direction: column;\n      gap: 4px;\n\n      &:hover {\n        border-color: rgb(0 0 0 / 0.5) !important;\n        box-shadow:\n          0 4px 6px -1px rgb(0 0 0 / 0.1),\n          0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n        transform: translateY(-2px) !important;\n      }\n\n      &:active {\n        transform: scale(0.98) !important;\n        box-shadow: none !important;\n      }\n\n      &.is--selected {\n        border-color: var(--pfd-border-color-selected) !important;\n        background: var(--pfd-background) !important;\n        box-shadow:\n          0 0 0 1px rgb(0 0 0 / 0.2),\n          0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n      }\n\n      &.is--soldout {\n        opacity: 1 !important;\n        background: #f5f5f5 !important;\n        color: var(--pfd-muted-color) !important;\n        cursor: pointer !important;\n        border: 2px solid rgba(198, 15, 46, 0.48)!important;\n      }\n\n      div[data-img-el] {\n        width: 100% !important;\n        height: 110px !important;\n        min-width: 40px !important;\n        max-width: 100% !important;\n        padding: 0px !important;\n        border-radius: .625rem !important;\n        border: 1px solid var(--pfd-border-color) !important;\n        flex-shrink: 0 !important;\n        overflow: hidden !important;\n        transition: transform 0.2s ease-out !important;\n\n        img {\n          width: 100% !important;\n          height: 100% !important;\n          object-fit: cover !important;\n          object-position: top left;\n        }\n\n        img[src=\"\"],\n        img:not([src]),\n        img[src=\"null\"] {\n          opacity: 0 !important;\n          visibility: hidden !important;\n        }\n      }\n    }\n\n    .pfd-split-option {\n      position: relative !important;\n      font-family: 'AeonikPro-Medium'\n    }\n\n    .pfd-split-selection {\n      display: flex !important;\n      align-items: center !important;\n      gap: 12px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-standard-options {\n      display: flex !important;\n      gap: 8px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-or-separator {\n      font-size: 14px !important;\n      color: var(--pfd-muted-color) !important;\n      margin: 0 4px !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n    }\n\n    .pfd-custom-options {\n      position: relative !important;\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n      gap: 8px;\n    }\n\n    .pfd-custom-dropdown {\n      font-weight: 500 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      min-width: 200px !important;\n      min-height: 44px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: space-between !important;\n      cursor: pointer !important;\n      font-family: var(--font-body-family) !important;\n      color: rgb(20, 20, 20) !important;\n      outline: none !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-dropdown:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n    }\n\n    .pfd-custom-dropdown:focus,\n    .pfd-custom-dropdown:active {\n      outline: none !important;\n      border-color: var(--pfd-border-color-selected) !important;\n    }\n\n    .pfd-custom-dropdown:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .pfd-custom-dropdown .t4s-icon-select-arrow {\n      width: 12px !important;\n      height: 12px !important;\n      margin-left: 8px !important;\n      flex-shrink: 0 !important;\n      transition: transform 0.2s ease !important;\n    }\n\n    .pfd-custom-dropdown[aria-expanded=\"true\"] .t4s-icon-select-arrow {\n      transform: rotate(180deg) !important;\n    }\n\n    .pfd-custom-dropdown::after {\n      content: \"New\" !important;\n      position: absolute !important;\n      top: -12px !important;\n      right: -12px !important;\n      background: var(--pfd-border-color-selected) !important;\n      color: #fff !important;\n      font-size: 10px !important;\n      font-weight: 600 !important;\n      padding: 6px 12px !important;\n      border-radius: 12px !important;\n      line-height: 1 !important;\n      text-transform: uppercase !important;\n      letter-spacing: 0.5px !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper {\n      position: absolute !important;\n      top: 100% !important;\n      left: 0 !important;\n      right: auto !important;\n      min-width: 280px !important;\n      width: max-content !important;\n      z-index: 1000 !important;\n      border-radius: 12px !important;\n      box-shadow:\n        0 10px 25px -3px rgb(0 0 0 / 0.15),\n        0 4px 6px -2px rgb(0 0 0 / 0.05) !important;\n      border: 1px solid rgb(220, 220, 220) !important;\n      background: #ffffff !important;\n      overflow: hidden !important;\n      margin-top: 8px !important;\n      opacity: 0 !important;\n      transform: translateY(-10px) !important;\n      transition:\n        opacity 0.2s ease,\n        transform 0.2s ease !important;\n      visibility: hidden !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper.is-open {\n      opacity: 1 !important;\n      transform: translateY(0) !important;\n      visibility: visible !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__content {\n      max-height: 300px !important;\n      overflow-y: auto !important;\n      padding: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item {\n      padding: 0px 8px !important;\n      border: none !important;\n      border-radius: 8px !important;\n      background: #ffffff !important;\n      font-size: 15px !important;\n      cursor: pointer !important;\n      transition: all 0.15s ease !important;\n      font-family: var(--pfd-font-family) !important;\n      color: #333333 !important;\n      margin: 4px !important;\n      height: auto !important;\n      box-shadow: none !important;\n      transform: none !important;\n      font-weight: 500 !important;\n      display: flex !important;\n      width: calc(100% - 8px) !important;\n      text-align: left !important;\n      justify-content: space-between !important;\n      align-items: center !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:hover {\n      background: #f3f4f6 !important;\n      transform: none !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:active {\n      transform: none !important;\n      box-shadow: none !important;\n      background: #e5e7eb !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected {\n      background: #f3f4f6 !important;\n      color: #333333 !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    /* Active state for dropdown button when custom option is selected */\n    .pfd-custom-dropdown.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .pfd-custom-options .pfd-checkmark {\n      color: #10b981 !important;\n      font-size: 12px !important;\n      font-weight: 600 !important;\n      margin-right: 8px !important;\n      display: inline-block !important;\n      opacity: 0 !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected .pfd-checkmark {\n      opacity: 1 !important;\n    }\n\n    .pfd-custom-options .pfd-option-text {\n      flex: 1 !important;\n      display: inline-block !important;\n    }\n\n    .pfd-custom-options .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 13px !important;\n      font-weight: 500 !important;\n      padding: 4px 8px !important;\n      border-radius: 4px !important;\n      margin-left: 16px !important;\n      display: inline-block !important;\n      flex-shrink: 0 !important;\n      line-height: 10px !important;\n    }\n\n    .pfd-custom-dropdown .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 11px !important;\n      font-weight: 500 !important;\n      padding: 2px 6px !important;\n      border-radius: 3px !important;\n      margin-left: 8px !important;\n      display: inline-block !important;\n      vertical-align: middle !important;\n      line-height: 1.2 !important;\n    }\n\n    .pfd-custom-notice {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-notice-content {\n      background: rgba(243, 244, 246, 0.5) !important; /* bg-muted/50 */\n      border: 1px solid #d1d5db !important; /* border-border */\n      border-radius: 8px !important; /* rounded-lg */\n      padding: 12px 16px !important; /* px-4 py-3 */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 12px !important; /* gap-3 */\n    }\n\n    .pfd-custom-notice-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      margin-top: 2px !important; /* mt-0.5 */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-notice-text {\n      font-size: 14px !important; /* text-sm */\n      margin: 0 !important;\n      line-height: 1.4 !important;\n      color: #374151 !important;\n    }\n\n    .pfd-custom-notice-text strong {\n      color: #111827 !important; /* text-foreground */\n      font-weight: 600 !important;\n    }\n\n    .pfd-custom-notice-highlight {\n      font-weight: 600 !important; /* font-semibold */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-option-info {\n      margin: 16px 0 20px 0 !important;\n      color: var(--pfd-muted-color) !important;\n    }\n\n    .pfd-info-content {\n      color: var(--pfd-muted-color) !important;\n      font-size: 14px !important; /* text-sm */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 8px !important; /* gap-2 */\n    }\n\n    .pfd-info-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      border-radius: 50% !important; /* rounded-full */\n      border: 1px solid rgba(107, 114, 128, 0.3) !important; /* border-muted-foreground/30 */\n      display: flex !important; /* flex */\n      align-items: center !important; /* items-center */\n      justify-content: center !important; /* justify-center */\n      font-size: 12px !important; /* text-xs */\n      margin-top: 2px !important; /* mt-0.5 */\n      font-weight: 500 !important;\n      background: #ffffff !important;\n    }\n\n    .pfd-info-text {\n      line-height: 1.4 !important;\n    }\n\n    .pfd-custom-option-content {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-option-content p {\n      margin: 0 !important;\n      font-size: 14px !important;\n      line-height: 1.4 !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right {\n      position: absolute !important;\n      right: 0 !important;\n      top: 0 !important;\n      font-size: 14px !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right .bold {\n      font-weight: 600 !important;\n      color: var(--pfd-text-color) !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__item.swatch-loading,\n    .pfd-standard-options .t4s-swatch__item.swatch-loading {\n      opacity: 0.6 !important;\n      pointer-events: none !important;\n    }\n\n    .t4s-swatch__item.swatch-error,\n    .pfd-standard-options .t4s-swatch__item.swatch-error {\n      background: #f5f5f5 !important;\n      color: var(--pfd-muted-color) !important;\n      border-color: #ddd !important;\n    }\n\n    .t4s-swatch__item:focus,\n    .pfd-standard-options .t4s-swatch__item:focus {\n      outline: 2px solid var(--pfd-border-color-selected) !important;\n      outline-offset: 2px !important;\n    }\n\n    @media (max-width: 1536px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n    }\n\n    @media (max-width: 1080px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n    }\n\n    @media (max-width: 768px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n\n      .pfd-split-selection {\n        flex-direction: column !important;\n        align-items: flex-start !important;\n        gap: 16px !important;\n      }\n\n      .pfd-standard-options {\n        width: 100% !important;\n      }\n\n      .pfd-or-separator {\n        display: none;\n      }\n\n      .pfd-custom-dropdown {\n        width: 100% !important;\n        min-width: 200px !important;\n      }\n\n      .pfd-or-separator {\n        align-self: center !important;\n        margin: 0 !important;\n      }\n    }\n\n    @media (max-width: 480px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n\n      .t4s-swatch__item,\n      .pfd-standard-options .t4s-swatch__item {\n        min-width: 45px !important;\n        height: 36px !important;\n        font-size: 13px !important;\n        padding: 0 8px !important;\n      }\n\n      .pfd-split-option .t4s-swatch__title--right {\n        position: static !important;\n        display: block !important;\n      }\n\n      .pfd-custom-dropdown {\n        height: 36px !important;\n        font-size: 13px !important;\n      }\n    }\n  }\n}\n",
              "reasoning": "Replace the old absolute-positioned overlay approach with a normal-flow element that sits below the swatch image. The lengths text is now a direct child of .t4s-swatch__btn-wrap, displayed as a block below the swatch item."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "edit_lines",
            "id": "toolu_016m9aqSK6SxjAsqjnWcbdEL",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "startLine": 173,
              "endLine": 229,
              "newContent": "/* ============================================\n   AVAILABLE LENGTHS TEXT\n   Shown below the swatch image, under the restock badge\n   ============================================ */\n.t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 3px;\n\n  /* Default: muted dark text */\n  color: rgba(0, 0, 0, 0.65);\n\n  font-size: 7px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: nowrap;\n  pointer-events: none;\n  line-height: 1.2;\n}\n\n/* Show when JS adds .is-visible class */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: Light background = dark text */\n[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(0, 0, 0, 0.65);\n}\n\n/* Content-aware contrast: Dark background = light text */\n[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.85);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS VISIBILITY CONTROL\n   Element lives as direct child of .t4s-swatch__btn-wrap\n   ============================================ */\n\n/* Hide by default — JS controls visibility via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n/* Show when JS adds .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Ensure btn-wrap stacks vertically so text sits below the swatch */\n.t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n",
              "reasoning": "Replace the old absolute-positioned overlay approach with a normal-flow element that sits below the swatch image. The lengths text is now a direct child of .t4s-swatch__btn-wrap, displayed as a block below the swatch item."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772169878278",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths\n    const lengthsEl = el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const lengthOptIdx = window.__LENGTH_OPTION_INDEX__;\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  if (lengthOptIdx == null || lengthOptIdx < 0) return;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Collect available standard lengths for this color (ignoring other option constraints)\n  const seen = new Set();\n  const lengths = [];\n\n  for (const v of variantById.values()) {\n    if (!v || !v.available) continue;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) continue;\n\n    const vLength = v[`option${lengthOptIdx + 1}`] || \"\";\n    if (!vLength) continue;\n\n    // Skip custom lengths\n    const isCustom = customNames.some(\n      (cn) => String(cn).trim() === String(vLength).trim(),\n    );\n    if (isCustom) continue;\n\n    const cleanLength = String(vLength).replace(/\"/g, \"\");\n    if (!seen.has(cleanLength)) {\n      seen.add(cleanLength);\n      lengths.push(cleanLength);\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // (swatchEl's parent), so it renders below the swatch image in normal flow.\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (lengths.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + lengths.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Place the available lengths element as a direct child of .t4s-swatch__btn-wrap (swatchEl.parentNode) so it renders below the swatch in normal document flow, not as an overlay inside the image container."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "edit_lines",
            "id": "toolu_01MQp2gFbMeLNfnesn5XygRu",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 744,
              "endLine": 769,
              "newContent": "  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // (swatchEl's parent), so it renders below the swatch image in normal flow.\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (lengths.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + lengths.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n",
              "reasoning": "Place the available lengths element as a direct child of .t4s-swatch__btn-wrap (swatchEl.parentNode) so it renders below the swatch in normal document flow, not as an overlay inside the image container."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772169885422",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const lengthOptIdx = window.__LENGTH_OPTION_INDEX__;\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  if (lengthOptIdx == null || lengthOptIdx < 0) return;\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Collect available standard lengths for this color (ignoring other option constraints)\n  const seen = new Set();\n  const lengths = [];\n\n  for (const v of variantById.values()) {\n    if (!v || !v.available) continue;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) continue;\n\n    const vLength = v[`option${lengthOptIdx + 1}`] || \"\";\n    if (!vLength) continue;\n\n    // Skip custom lengths\n    const isCustom = customNames.some(\n      (cn) => String(cn).trim() === String(vLength).trim(),\n    );\n    if (isCustom) continue;\n\n    const cleanLength = String(vLength).replace(/\"/g, \"\");\n    if (!seen.has(cleanLength)) {\n      seen.add(cleanLength);\n      lengths.push(cleanLength);\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  // (swatchEl's parent), so it renders below the swatch image in normal flow.\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (lengths.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"Available in \" + lengths.join(\", \");\n    lengthsEl.classList.add(\"is-visible\");\n  } else if (lengthsEl) {\n    lengthsEl.classList.remove(\"is-visible\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Update the hide path in setSoldOut to look for the lengths element as a direct child of the btn-wrap parent, matching the new placement logic."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          },
          {
            "name": "edit_lines",
            "id": "toolu_01JsYoL341ZM88s96QJRzsY2",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 691,
              "endLine": 695,
              "newContent": "    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n",
              "reasoning": "Update the hide path in setSoldOut to look for the lengths element as a direct child of the btn-wrap parent, matching the new placement logic."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 1
          }
        ],
        "reasoningBlocks": [],
        "responseText": "",
        "outcome": {
          "status": "applied",
          "changedFiles": 3,
          "changeSummary": "product-form-dynamic.css: Replace the old absolute-positioned overlay approach with a normal-flow element that sits below the swatch image. The lengths text is now a direct child of .t4s-swatch__btn-wrap, displayed as a block below the swatch item.\nproduct-form-dynamic.js: Place the available lengths element as a direct child of .t4s-swatch__btn-wrap (swatchEl.parentNode) so it renders below the swatch in normal document flow, not as an overlay inside the image container.",
          "validationIssues": [
            {
              "gate": "theme_check",
              "errors": [
                "templates/page.ecom-deadfest2025.json — Invalid JSON in template file",
                "templates/article.portfolio.json — Invalid JSON in template file",
                "templates/page.ecom-deaducation-live-phoenix.json — Invalid JSON in template file",
                "templates/index.ecom-preview-home.json — Invalid JSON in template file",
                "templates/index.ecom-preview-page.json — Invalid JSON in template file"
              ],
              "changesKept": true
            }
          ]
        },
        "metrics": {
          "totalToolCalls": 19,
          "editToolCalls": 6,
          "readToolCalls": 10,
          "searchToolCalls": 1,
          "elapsedMs": 148758,
          "costCents": 29,
          "inputTokens": 75496,
          "outputTokens": 4173
        }
      },
      "analysis": {
        "diagnosis": {
          "summary": "Agent executed 19 tool calls over 149s, with 10 reads and 6 edits reported as successful, but tools 11-19 all returned [ERROR] with no result received. Despite these errors, the system reports 3 files changed and a complete solution. This indicates either: (1) error handling masked actual failures, (2) tool executor silently succeeded despite error signals, or (3) errors occurred post-execution in reporting/validation layers.",
          "rootCause": "The tool executor (lib/agents/tools/v2-tool-executor.ts) or coordinator error handling is not properly propagating or logging tool failures. Tools 11-19 show explicit [ERROR] markers but the agent continued and reported success. This suggests either swallowed exceptions, incorrect error classification, or a disconnect between tool execution state and error reporting.",
          "agentBehavior": "Agent correctly identified target files (product-form-dynamic.js, product-form-dynamic.css), performed initial reconnaissance with 10 successful read_lines calls, then attempted semantic_search and extract_region (tools 11-13) which failed silently. Despite these failures, the agent proceeded to propose and execute edits (tools 14-19), all marked [ERROR], yet the final output claims 3 files were modified. The agent did not retry, escalate, or request second opinion despite cascading tool failures."
        },
        "recommendations": [
          {
            "priority": "critical",
            "category": "tools",
            "title": "Fix tool executor error handling and result propagation",
            "description": "The v2-tool-executor is not properly catching, logging, or propagating errors from tool calls. Tools 11-19 show [ERROR] markers but execution continued without retry or escalation. Implement proper error classification (transient vs. fatal), logging of actual error messages, and coordinator-level awareness of tool failures.",
            "targetFile": "lib/agents/tools/v2-tool-executor.ts",
            "targetArea": "run_specialist, run_review, and individual tool invocation handlers",
            "suggestedChange": "Wrap each tool call in try-catch with detailed error logging. Return structured error objects with { success: false, error: string, toolName: string, retryable: boolean } instead of silent failures. Log full error stack. Ensure coordinator receives complete error context."
          },
          {
            "priority": "critical",
            "category": "coordinator",
            "title": "Add error recovery and escalation logic to coordinator loop",
            "description": "Coordinator does not detect or respond to tool failures. When tools 11-19 failed, the agent should have either: (1) retried with different parameters, (2) requested a second opinion, or (3) escalated to review. Currently the loop treats [ERROR] as a non-blocking event and continues.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Main loop iteration, tool result observation, context validation gates",
            "suggestedChange": "After each tool execution, check result.success or catch error signal. If tool fails: increment failure counter per tool type. If consecutive failures on same tool exceed threshold (e.g., 2), trigger run_review or get_second_opinion. If total failures exceed 5 in a session, escalate to human review or abort with clear error message. Log all failures to transcript."
          },
          {
            "priority": "high",
            "category": "validation",
            "title": "Implement pre-execution validation for tool parameters",
            "description": "Tools 14-19 (propose_code_edit, edit_lines) failed, likely due to malformed parameters or missing context. The orchestration-policy validation gates should catch these before execution. Currently semantic_search and extract_region also failed (tools 11-13), suggesting poor parameter construction.",
            "targetFile": "lib/agents/orchestration-policy.ts",
            "targetArea": "Context gates, pre-tool-call validation rules",
            "suggestedChange": "Add pre-execution validation for propose_code_edit and edit_lines: verify filePath exists in context, verify line ranges are within file bounds, verify reasoning is non-empty. For semantic_search, validate query is specific enough. For extract_region, validate hint matches known function/class names in scout brief. Return validation error before tool execution if checks fail."
          },
          {
            "priority": "high",
            "category": "tools",
            "title": "Add semantic_search and extract_region fallback strategies",
            "description": "Tools 11-13 (semantic_search, extract_region) returned no results. These are search/navigation tools that should have graceful fallbacks. semantic_search with query about 'updateAvailableLengths' failed, suggesting the query was too specific or the tool doesn't support the search pattern.",
            "targetFile": "lib/agents/tools/v2-tool-definitions.ts",
            "targetArea": "semantic_search and extract_region tool definitions and descriptions",
            "suggestedChange": "For semantic_search: add fallback to grep_content if semantic search returns empty. Add guidance in tool description to use shorter, more general queries. For extract_region: add fallback to read_lines with scout-provided line hints. Include in tool description that extract_region requires exact function/class name match from scout brief."
          },
          {
            "priority": "high",
            "category": "context",
            "title": "Ensure scout brief includes all target function names and line ranges",
            "description": "Agent attempted extract_region for 'setSoldOut', 'getSwatchItems' but both returned no results. Scout brief may not have indexed these functions, or they may not exist in the files. This caused the agent to fall back to manual read_lines + propose_code_edit, which then failed.",
            "targetFile": "lib/agents/scout/structural-scout.ts",
            "targetArea": "Scout brief generation for JS files, function extraction",
            "suggestedChange": "Enhance scout to extract all top-level and class method names from JS files. Include line ranges for each function. When briefing coordinator, provide a 'functionIndex' map: { functionName: lineRange }. Validate that scout can locate functions before agent attempts extract_region."
          },
          {
            "priority": "medium",
            "category": "prompt",
            "title": "Add error recovery instructions to PM system prompt",
            "description": "Agent did not recognize or respond to cascading tool failures. The system prompt should guide the agent to detect [ERROR] signals and take corrective action.",
            "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
            "targetArea": "Tool usage instructions, error handling guidance section",
            "suggestedChange": "Add explicit instructions: 'If a tool returns [ERROR] or no result, do not proceed with dependent tools. Instead: (1) Log the failure. (2) Retry with different parameters if applicable. (3) Request a second opinion. (4) Escalate to review if more than 2 tools fail in sequence.' Include examples of error signals to watch for."
          },
          {
            "priority": "medium",
            "category": "coordinator",
            "title": "Add iteration transcript logging for debugging",
            "description": "Agent reasoning blocks are empty ('no reasoning captured'), making it impossible to understand why the agent continued despite tool failures. Coordinator should capture and log reasoning for each iteration.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Iteration loop, thought/observe blocks, transcript building",
            "suggestedChange": "After each LLM thought step, capture the full reasoning text. Log it to transcript with iteration number. Include tool result summaries and agent's interpretation of success/failure. This provides visibility into decision-making and helps detect when agent ignores error signals."
          },
          {
            "priority": "low",
            "category": "strategy",
            "title": "Consider strategy downgrade on repeated tool failures",
            "description": "GOD_MODE strategy with Sonnet-4 was selected for COMPLEX tier, but the agent encountered multiple tool failures and did not adapt. If a strategy is not yielding results, coordinator should offer to downgrade or request human input.",
            "targetFile": "lib/agents/strategy.ts",
            "targetArea": "Strategy selection, runtime adaptation logic",
            "suggestedChange": "Add adaptive strategy logic: if tool failure rate exceeds 20% in first 10 iterations, suggest downgrade to HYBRID. If failure rate exceeds 40%, suggest SIMPLE or escalate to human. Log strategy change rationale to transcript."
          }
        ]
      }
    }
  ],
  "summary": {
    "passRate": "1/1 (100%)",
    "avgToolCalls": 19,
    "avgTimeSeconds": 149,
    "totalCostCents": 29,
    "failureReasons": []
  },
  "aggregateAnalysis": {
    "diagnosis": {
      "summary": "Single successful run (100% pass rate) with notable tool error pattern: 9 errors across 19 tool calls (47% error rate on specific tools), yet task completed successfully. Errors clustered in semantic_search, extract_region, and propose_code_edit—suggesting these tools either returned no result gracefully or failed silently without blocking execution.",
      "rootCause": "Tool error handling is permissive—errors in semantic_search, extract_region, and propose_code_edit do not halt iteration. The agent recovered by using alternative approaches (read_lines, check_lint, edit_lines succeeded). This indicates either: (1) error responses were handled gracefully in coordinator retry logic, or (2) tool failures were logged but execution continued. The 100% pass rate suggests the recovery mechanism worked, but the 47% error rate indicates instability in these specific tools.",
      "agentBehavior": "Agent employed a read-heavy strategy initially (7 sequential read_lines calls), then shifted to semantic_search and extract_region for targeted code location, fell back to direct read_lines when those failed, and completed edits via propose_code_edit + edit_lines cycle. Despite tool errors, the agent maintained forward progress through fallback patterns."
    },
    "recommendations": [
      {
        "priority": "critical",
        "category": "tools",
        "title": "Harden semantic_search error handling and result validation",
        "description": "semantic_search returned no result in 1 call. This tool is critical for efficient code location but failed silently. Add explicit validation in v2-tool-executor.ts to: (1) log when semantic_search returns empty, (2) trigger automatic fallback to grep_content or read_lines, (3) include search query and context in error logs for debugging.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "semantic_search execution handler",
        "suggestedChange": "Wrap semantic_search result in validation gate: if (result.length === 0) { log warning with query + context; suggest fallback tool to coordinator }"
      },
      {
        "priority": "critical",
        "category": "tools",
        "title": "Add result validation and fallback logic for extract_region",
        "description": "extract_region returned no result in 2 calls (10.5% of total tool calls). This tool is used after successful reads to isolate code regions. Failures suggest either invalid region bounds or tool implementation issues. Add: (1) pre-call validation of line ranges against file length, (2) fallback to raw read_lines if extraction fails, (3) explicit error logging with region specs.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "extract_region execution handler",
        "suggestedChange": "Validate start_line < end_line < file_length before call; on failure, return raw read_lines result with warning; log region specs and file metadata for debugging"
      },
      {
        "priority": "high",
        "category": "coordinator",
        "title": "Implement explicit tool error recovery strategy in main loop",
        "description": "The agent recovered from 9 tool errors without explicit coordinator-level recovery logic visible in this run. Current behavior is either silent retry or permissive error handling. Formalize recovery by: (1) tracking consecutive failures per tool, (2) disabling tools after 2 consecutive failures, (3) automatically switching to alternative tools (e.g., semantic_search → grep_content → read_lines), (4) logging recovery path for observability.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Tool execution and error handling loop",
        "suggestedChange": "Add toolErrorTracker: Map<toolName, errorCount>; on tool error, increment counter; if errorCount >= 2, disable tool and suggest alternative; log recovery decision"
      },
      {
        "priority": "high",
        "category": "tools",
        "title": "Validate propose_code_edit responses before edit_lines execution",
        "description": "propose_code_edit returned no result in 3 calls, yet edit_lines was called 3 times after. This suggests either: (1) propose_code_edit is generating code silently, or (2) edit_lines is being called with incomplete/invalid proposals. Add validation in v2-tool-executor.ts to ensure propose_code_edit returns structured code before passing to edit_lines.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "propose_code_edit → edit_lines handoff",
        "suggestedChange": "Validate propose_code_edit result schema (code, startLine, endLine) before edit_lines call; if invalid, log and ask coordinator for clarification step"
      },
      {
        "priority": "high",
        "category": "prompt",
        "title": "Add explicit error recovery guidance to PM prompt",
        "description": "The PM prompt should guide the agent to recognize when semantic_search or extract_region fail and switch strategies. Current prompt may not include fallback decision trees for tool failures.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Tool instructions and error handling section",
        "suggestedChange": "Add section: 'If semantic_search returns empty, use grep_content with keywords. If extract_region fails, use read_lines with explicit line range. Always validate tool results before proceeding.'"
      },
      {
        "priority": "medium",
        "category": "validation",
        "title": "Add pre-execution validation for file-dependent tools",
        "description": "Multiple read_lines calls at start suggest agent was building context. Some tools (extract_region, semantic_search) depend on prior reads. Add orchestration-policy.ts validation to ensure file metadata (length, line count) is cached before dependent tools are called.",
        "targetFile": "lib/agents/orchestration-policy.ts",
        "targetArea": "Context gates and tool preconditions",
        "suggestedChange": "Add gate: extract_region and semantic_search require cached file metadata; if missing, auto-call read_lines first to populate cache"
      },
      {
        "priority": "medium",
        "category": "strategy",
        "title": "Consider HYBRID strategy for code editing tasks",
        "description": "Run used 19 tools across 3 files with mixed success. HYBRID strategy (per strategy.ts) could optimize by: (1) using Scout to pre-identify files, (2) batching reads, (3) using semantic_search only when grep fails. Ensure strategy selection logic in strategy.ts triggers HYBRID for Shopify theme edits.",
        "targetFile": "lib/agents/strategy.ts",
        "targetArea": "Strategy selection for tier/task type",
        "suggestedChange": "Add condition: if (task.involves('code_edit') && files.length <= 5) use HYBRID; log strategy selection for observability"
      },
      {
        "priority": "medium",
        "category": "context",
        "title": "Ensure Scout pre-populates file list for theme edits",
        "description": "Agent read 7 files sequentially before targeting edits. Scout (structural-scout.ts) should identify target files programmatically. Verify Scout is being called and its output is used to pre-filter file candidates before main loop.",
        "targetFile": "lib/agents/scout/structural-scout.ts",
        "targetArea": "Scout brief generation and file targeting",
        "suggestedChange": "Ensure Scout identifies files related to 'Awaiting Restock badge' and 'length options' before PM loop starts; pass file list to coordinator for context prioritization"
      }
    ],
    "patterns": {
      "consistentFailureMode": null,
      "intermittentIssues": [
        "semantic_search: no result (1 occurrence) — suggests query specificity or index coverage issue",
        "extract_region: no result (2 occurrences) — suggests invalid region bounds or tool implementation bug",
        "propose_code_edit: no result (3 occurrences) — suggests incomplete code generation or silent failures"
      ],
      "toolUsageAntiPatterns": [
        "Sequential read_lines calls (7 in a row) before semantic_search — suggests agent building context rather than targeting; could use Scout briefing instead",
        "semantic_search → extract_region → read_lines fallback chain — indicates semantic_search unreliability; should have direct fallback to grep_content",
        "propose_code_edit failures not blocking edit_lines calls — suggests permissive error handling or missing validation; edit_lines may be operating on incomplete proposals"
      ],
      "contextGaps": [
        "No explicit file targeting before reads — agent should have used Scout to identify 'product availability', 'badge', 'length' related files first",
        "No theme map lookup visible — theme-map/lookup.ts should have pre-populated file list for Shopify theme structure",
        "No grep_content usage despite semantic_search failures — agent should have pivoted to grep_content as secondary search strategy"
      ]
    }
  }
}