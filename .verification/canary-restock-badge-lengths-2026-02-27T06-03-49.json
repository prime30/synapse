{
  "timestamp": "2026-02-27T06:03:49.350Z",
  "projectId": "838e7498-6dc5-4268-9fcd-e6f6148f65ad",
  "scenario": "restock-badge-lengths",
  "prompt": "Add available lengths text under the \"Awaiting Restock\" badge when a color is out of stock in the currently selected length but available in other lengths. Show which non-color options are still available for that color.",
  "totalRuns": 1,
  "results": [
    {
      "run": 1,
      "passed": false,
      "reason": "Too many tool calls (27/25) — looping",
      "metrics": {
        "totalToolCalls": 27,
        "editToolCalls": 8,
        "readToolCalls": 16,
        "searchToolCalls": 1,
        "elapsedMs": 239470,
        "costCents": 45,
        "inputTokens": 111387,
        "outputTokens": 7428
      },
      "tier": "COMPLEX",
      "strategy": "GOD_MODE",
      "changedFiles": [
        "assets/product-form-dynamic.js",
        "assets/product-form-dynamic.css",
        "assets/swatch.css",
        "product-form-dynamic.css",
        "product-form-dynamic.js"
      ],
      "transcript": {
        "runId": "run-1",
        "scenario": "restock-badge-lengths",
        "decisions": [
          {
            "phase": "analyzing",
            "label": "Loading context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Context ready",
            "detail": "606 files, 5 prefs",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Classifying request...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Preparing file context...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Building structural brief...",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Starting agent...",
            "timestamp": 0
          },
          {
            "phase": "strategy",
            "label": "Strategy: GOD_MODE",
            "detail": "strategy=GOD_MODE, tier=COMPLEX",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "COMPLEX tier — GOD_MODE strategy — claude-sonnet-4-6",
            "detail": "routingTier=COMPLEX, strategy=GOD_MODE",
            "timestamp": 0
          },
          {
            "phase": "analyzing",
            "label": "Style profile loaded",
            "detail": "styleProfileRules=8, designTokenCount=0, patternConflictResolutions=0, referenceSectionsLoaded=0, cssPreloaded=false, snippetConsumers=0",
            "timestamp": 0
          }
        ],
        "toolSequence": [
          {
            "name": "read_lines",
            "id": "toolu_0196djGSjpRZLPZyV3JNuapL",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 695,
                  "endLine": 830
                },
                {
                  "startLine": 890,
                  "endLine": 935
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_017zjTsRxnBDUjA6MM7ZUWiA",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 937,
                  "endLine": 1050
                },
                {
                  "startLine": 1050,
                  "endLine": 1150
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_014fAA6c7N8zKnc2U81L8u3u",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 620,
                  "endLine": 705
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_014u4jyYHXJMbCyiNZpW3iPb",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 1,
                  "endLine": 50
                },
                {
                  "startLine": 400,
                  "endLine": 445
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01VAoxyYn2gKMLqZLyqyzUkY",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 175,
                  "endLine": 260
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_019zCD5bMd63Jzuc8mmhPjCD",
            "input": {
              "filePath": "assets/swatch.css",
              "ranges": [
                {
                  "startLine": 60,
                  "endLine": 100
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01S5qjDuRwQAuiPLeQ8BMcqW",
            "input": {
              "filePath": "assets/swatch.css",
              "ranges": [
                {
                  "startLine": 100,
                  "endLine": 175
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01Pc7s8BWEkRjkYzymit8H8h",
            "input": {
              "filePath": "assets/swatch.css",
              "ranges": [
                {
                  "startLine": 480,
                  "endLine": 530
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01PnjBHTLzvbFPLJ3Gm7LhHn",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 550,
                  "endLine": 620
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01BetFV3sonfF67KKsr6Ny28",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "ranges": [
                {
                  "startLine": 210,
                  "endLine": 265
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01RJbPkHhgoHcEk61sfi7Zmb",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 807,
                  "endLine": 830
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01HqgtT2ACFnmRNTQNtAXQvq",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 688,
                  "endLine": 702
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01RPfXHXjZXcNnHWxb7KgWNG",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 2120,
                  "endLine": 2135
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01Gxbfwhb3ZRUp4PKHE5EUgk",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "ranges": [
                {
                  "startLine": 649,
                  "endLine": 705
                },
                {
                  "startLine": 805,
                  "endLine": 840
                }
              ]
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_01QQ34D3CZgGitYr1iBcMfi2",
            "input": {
              "fileName": "assets/product-form-dynamic.js"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "check_lint",
            "id": "toolu_012bugY8sjkzNq4osHXh3fVB",
            "input": {
              "fileName": "assets/product-form-dynamic.css"
            },
            "result": "",
            "isError": false,
            "elapsedMs": 0
          },
          {
            "name": "semantic_search",
            "id": "toolu_01QQZnw7ZJ2opDzj57vNirKf",
            "input": {
              "query": ".t4s-swatch__btn-wrap display layout flex",
              "limit": 3
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "extract_region",
            "id": "toolu_01YPXNdoQp95PbVNwJW936JU",
            "input": {
              "fileId": "assets/swatch.css",
              "hint": ".t4s-swatch__btn-wrap"
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "read_lines",
            "id": "toolu_01WuJoLrTzTY7HDdeV66j8Y6",
            "input": {
              "_error": true,
              "message": "Failed to parse tool input JSON"
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772172066658",
            "input": {
              "filePath": "product-form-dynamic.css",
              "newContent": "/* Hidden state for unavailable colors when custom option is selected */\n.t4s-swatch__btn-wrap.pfd-hidden-custom {\n  display: none !important;\n}\n\n.pfd-override-wrapper {\n\n  --pfd-border-color: rgb(230, 230, 230);\n  --pfd-border-color-selected: rgb(20, 20, 20);\n  --pfd-background: #ffffff;\n  --pfd-text-color: rgb(20, 20, 20);\n  --pfd-muted-color: rgb(115, 115, 115);\n\n  .pfd-custom-wrapper {\n    font-family: 'AeonikPro-Medium' !important;\n\n    .bold {\n      font-weight: bold !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__title {\n      display: flex !important;\n      flex-direction: row !important;\n      justify-content: space-between !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n      font-size: 14px !important;\n      text-transform: none !important;\n      color: var(--pfd-muted-color) !important;\n\n      .t4s-swatch__title--left span {\n        color: var(--pfd-text-color) !important;\n      }\n\n      .t4s-swatch__title--right {\n        color: var(--pfd-text-color) !important;\n        text-align: right !important;\n      }\n    }\n\n    .t4s-swatch__title--color {\n      color: var(--pfd-text-color) !important;\n      font-size: 14px !important;\n    }\n\n    .t4s-swatch__list {\n      gap: 8px !important;\n      margin: 0 !important;\n    }\n\n/* Awaiting Restock Badge - Glassmorphism with Content-Aware Contrast */\n.t4s-swatch__btn-wrap,\n.t4s-swatch__item {\n  position: relative;\n}\n\n/* Ensure image container is positioned for badge anchoring */\ndiv[data-img-el] {\n  position: relative !important;\n}\n\n.t4s-swatch__restock-badge {\n  position: absolute;\n  bottom: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n\n  /* Caustic glass effect - 5% opacity with blur */\n  background: rgba(0, 0, 0, 0.05);\n  backdrop-filter: blur(10px) saturate(1.2);\n  -webkit-backdrop-filter: blur(10px) saturate(1.2);\n\n  /* Default: dark text for light backgrounds */\n  color: rgba(0, 0, 0, 0.85);\n\n  font-size: 8px;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  white-space: nowrap;\n  z-index: 2;\n  pointer-events: none;\n\n  /* Subtle border for definition */\n  border: 1px solid rgba(0, 0, 0, 0.08);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);\n}\n/* Ensure image container is positioned for badge anchoring */\ndiv[data-img-el] {\n  position: relative !important;\n}\n\n.t4s-swatch__restock-badge {\n  position: absolute;\n  bottom: 8px;\n  left: 50%;\n  transform: translateX(-50%);\n\n  /* Caustic glass effect - 5% opacity with blur */\n  background: rgba(0, 0, 0, 0.05);\n  backdrop-filter: blur(10px) saturate(1.2);\n  -webkit-backdrop-filter: blur(10px) saturate(1.2);\n\n  /* Default: dark text for light backgrounds */\n  color: rgba(0, 0, 0, 0.85);\n\n  font-size: 8px;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n  padding: 5px 10px;\n  border-radius: 4px;\n  white-space: nowrap;\n  z-index: 2;\n  pointer-events: none;\n\n  /* Subtle border for definition */\n  border: 1px solid rgba(0, 0, 0, 0.08);\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);\n}\n\n/* ============================================\n   RESTOCK BADGE VISIBILITY CONTROL\n   Class-based toggle for JS compatibility\n   INSERT THESE RULES HERE ↓\n   ============================================ */\n\n/* Hide badge outside image container (direct child of wrapper) */\n.t4s-swatch__btn-wrap > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Default: hide badge inside image container */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n/* Show only when JS adds .is-visible class */\n.t4s-swatch__btn-wrap [data-img-el] .t4s-swatch__restock-badge.is-visible {\n  display: flex !important;\n}\n\n/* For non-image swatches (length/text): also class-based */\n.t4s-swatch__item > .t4s-swatch__restock-badge {\n  display: none !important;\n}\n\n.t4s-swatch__item > .t4s-swatch__restock-badge.is-visible {\n  display: block !important;\n}\n\n/* ============================================\n   END VISIBILITY CONTROL\n   ============================================ */\n/* Content-aware contrast: Light background (dark hair) = dark text */\n[data-luminance=\"light\"] .t4s-swatch__restock-badge {\n  background: rgba(0, 0, 0, 0.05);\n  color: rgba(0, 0, 0, 0.85);\n  border-color: rgba(0, 0, 0, 0.1);\n}\n\n/* Content-aware contrast: Dark background (light hair) = light text */\n[data-luminance=\"dark\"] .t4s-swatch__restock-badge {\n  background: rgba(255, 255, 255, 0.05);\n  color: rgba(255, 255, 255, 0.95);\n  border-color: rgba(255, 255, 255, 0.15);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS TEXT\n   Shown below the swatch image, under the restock badge\n   ============================================ */\n.t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 4px;\n\n  /* Default: muted dark text */\n  color: rgba(0, 0, 0, 0.65);\n\n  font-size: 7px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: normal;\n  word-break: break-word;\n  pointer-events: none;\n  line-height: 1.3;\n  max-width: 100%;\n}\n\n/* Show when JS adds .is-visible class */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: Light background = dark text */\n[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(0, 0, 0, 0.65);\n}\n\n/* Content-aware contrast: Dark background = light text */\n[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.85);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS VISIBILITY CONTROL\n   Element lives as direct child of .t4s-swatch__btn-wrap\n   ============================================ */\n\n/* Hide by default — JS controls visibility via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n/* Show when JS adds .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Reflow btn-wrap to column when lengths text is visible.\n   JS also adds .pfd-has-lengths class directly for full browser support. */\n.t4s-swatch__btn-wrap.pfd-has-lengths,\n.t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex !important;\n  flex-direction: column !important;\n  align-items: center !important;\n  justify-content: center !important;\n}\n\n/* Compact version for circular/small swatches */\n.t4s-swatch__restock-badge--compact {\n  font-size: 7px;\n  padding: 3px 6px;\n}\n\n/* Keep full opacity on out-of-stock swatches for badge legibility */\n.t4s-swatch__btn-wrap.is--out-of-stock .t4s-swatch__item,\n.t4s-swatch__item.is--out-of-stock,\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el],\n.t4s-swatch__btn-wrap.is--out-of-stock div[data-img-el] img {\n  opacity: 1 !important;\n}\n\n/* Subtle hover effect */\n.t4s-swatch__btn-wrap.is--out-of-stock:hover .t4s-swatch__restock-badge,\n.t4s-swatch__item.is--out-of-stock:hover .t4s-swatch__restock-badge {\n  backdrop-filter: blur(12px) saturate(1.3);\n  -webkit-backdrop-filter: blur(12px) saturate(1.3);\n}\n/* Compact version for circular/small swatches */\n.t4s-swatch__restock-badge--compact {\n  font-size: 7px;\n  padding: 2px 4px;\n}\n\n/* Keep full opacity on out-of-stock swatches */\n.t4s-swatch__btn-wrap.is--out-of-stock .t4s-swatch__item,\n.t4s-swatch__item.is--out-of-stock {\n  opacity: 1; /* Override any default dimming */\n}\n\n/* Optional: subtle border indicator */\n.t4s-swatch__btn-wrap.is--out-of-stock,\n.t4s-swatch__item.is--out-of-stock {\n  border-color: rgba(0, 0, 0, 0.15);\n}\n\n/* Ensure badge doesn't interfere with selection */\n.t4s-swatch__btn-wrap.is--out-of-stock:hover .t4s-swatch__restock-badge,\n.t4s-swatch__item.is--out-of-stock:hover .t4s-swatch__restock-badge {\n  opacity: 0.9;\n}\n\n/* Color nickname styling - displays under swatch label */\n.t4s-swatch__nickname {\n  display: block;\n  font-size: 12px;\n  font-weight: 400;\n  color: var(--color-text-muted, #888);\n  text-align: center;\n  margin-top: 2px;\n  line-height: 1.3;\n}\n\n/* Ensure proper spacing in swatch wrapper */\n.t4s-swatch__btn-wrap {\n  text-align: center;\n}\n\n/* Adjust for label + nickname stacking */\n.t4s-swatch__btn-wrap .t4s-swatch__label {\n  display: block;\n  font-weight: 600;\n}\n\n    .t4s-swatch__item,\n    .pfd-standard-options .t4s-swatch__item {\n      font-weight: 600 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: center !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      user-select: none !important;\n    }\n\n    .t4s-swatch__item::before {\n      content: none !important;\n    }\n\n    .t4s-swatch__item:hover,\n    .pfd-standard-options .t4s-swatch__item:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n      transform: translateY(-2px) !important;\n    }\n\n    .t4s-swatch__item:active,\n    .pfd-standard-options .t4s-swatch__item:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .t4s-swatch__item.is--selected,\n    .pfd-standard-options .t4s-swatch__item.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .t4s-swatch__item.is--soldout,\n    .pfd-standard-options .t4s-swatch__item.is--soldout {\n      opacity: 0.7 !important;\n      /*background: #f5f5f5 !important;*/\n      color: var(--pfd-muted-color) !important;\n      cursor: pointer !important;\n    }\n.color-info-accordion-text{\n  font-family: 'AeonikPro-Medium'\n}\n    .t4s-swatch__btn-wrap {\n      font-weight: 600 !important;\n      height: auto !important;\n      width: calc(25% - 6px) !important;\n      margin: 0 !important;\n      padding: 8px 8px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 12px !important;\n      font-weight: 500 !important;\n      min-width: 48px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: flex-start !important;\n      cursor: pointer !important;\n      color: rgb(20, 20, 20) !important;\n      flex-direction: column;\n      gap: 4px;\n\n      &:hover {\n        border-color: rgb(0 0 0 / 0.5) !important;\n        box-shadow:\n          0 4px 6px -1px rgb(0 0 0 / 0.1),\n          0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n        transform: translateY(-2px) !important;\n      }\n\n      &:active {\n        transform: scale(0.98) !important;\n        box-shadow: none !important;\n      }\n\n      &.is--selected {\n        border-color: var(--pfd-border-color-selected) !important;\n        background: var(--pfd-background) !important;\n        box-shadow:\n          0 0 0 1px rgb(0 0 0 / 0.2),\n          0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n      }\n\n      &.is--soldout {\n        opacity: 1 !important;\n        background: #f5f5f5 !important;\n        color: var(--pfd-muted-color) !important;\n        cursor: pointer !important;\n        border: 2px solid rgba(198, 15, 46, 0.48)!important;\n      }\n\n      div[data-img-el] {\n        width: 100% !important;\n        height: 110px !important;\n        min-width: 40px !important;\n        max-width: 100% !important;\n        padding: 0px !important;\n        border-radius: .625rem !important;\n        border: 1px solid var(--pfd-border-color) !important;\n        flex-shrink: 0 !important;\n        overflow: hidden !important;\n        transition: transform 0.2s ease-out !important;\n\n        img {\n          width: 100% !important;\n          height: 100% !important;\n          object-fit: cover !important;\n          object-position: top left;\n        }\n\n        img[src=\"\"],\n        img:not([src]),\n        img[src=\"null\"] {\n          opacity: 0 !important;\n          visibility: hidden !important;\n        }\n      }\n    }\n\n    .pfd-split-option {\n      position: relative !important;\n      font-family: 'AeonikPro-Medium'\n    }\n\n    .pfd-split-selection {\n      display: flex !important;\n      align-items: center !important;\n      gap: 12px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-standard-options {\n      display: flex !important;\n      gap: 8px !important;\n      flex-wrap: wrap !important;\n    }\n\n    .pfd-or-separator {\n      font-size: 14px !important;\n      color: var(--pfd-muted-color) !important;\n      margin: 0 4px !important;\n      font-weight: normal !important;\n      font-family: var(--pfd-font-family) !important;\n    }\n\n    .pfd-custom-options {\n      position: relative !important;\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n      gap: 8px;\n    }\n\n    .pfd-custom-dropdown {\n      font-weight: 500 !important;\n      height: 44px !important;\n      margin: 0 !important;\n      padding: 0 16px !important;\n      border-radius: 8px !important;\n      border: 1px solid var(--pfd-border-color) !important;\n      font-size: 14px !important;\n      min-width: 200px !important;\n      min-height: 44px !important;\n      transition: all 0.2s ease-out !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0px 0px 0 rgb(0 0 0 / 0.05),\n        0 0 0 0px rgb(0 0 0 / 0.05) !important;\n      display: inline-flex !important;\n      align-items: center !important;\n      justify-content: space-between !important;\n      cursor: pointer !important;\n      font-family: var(--font-body-family) !important;\n      color: rgb(20, 20, 20) !important;\n      outline: none !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-dropdown:hover {\n      border-color: rgb(0 0 0 / 0.5) !important;\n      box-shadow:\n        0 4px 6px -1px rgb(0 0 0 / 0.1),\n        0 2px 4px -2px rgb(0 0 0 / 0.1) !important;\n    }\n\n    .pfd-custom-dropdown:focus,\n    .pfd-custom-dropdown:active {\n      outline: none !important;\n      border-color: var(--pfd-border-color-selected) !important;\n    }\n\n    .pfd-custom-dropdown:active {\n      transform: scale(0.98) !important;\n      box-shadow: none !important;\n    }\n\n    .pfd-custom-dropdown .t4s-icon-select-arrow {\n      width: 12px !important;\n      height: 12px !important;\n      margin-left: 8px !important;\n      flex-shrink: 0 !important;\n      transition: transform 0.2s ease !important;\n    }\n\n    .pfd-custom-dropdown[aria-expanded=\"true\"] .t4s-icon-select-arrow {\n      transform: rotate(180deg) !important;\n    }\n\n    .pfd-custom-dropdown::after {\n      content: \"New\" !important;\n      position: absolute !important;\n      top: -12px !important;\n      right: -12px !important;\n      background: var(--pfd-border-color-selected) !important;\n      color: #fff !important;\n      font-size: 10px !important;\n      font-weight: 600 !important;\n      padding: 6px 12px !important;\n      border-radius: 12px !important;\n      line-height: 1 !important;\n      text-transform: uppercase !important;\n      letter-spacing: 0.5px !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper {\n      position: absolute !important;\n      top: 100% !important;\n      left: 0 !important;\n      right: auto !important;\n      min-width: 280px !important;\n      width: max-content !important;\n      z-index: 1000 !important;\n      border-radius: 12px !important;\n      box-shadow:\n        0 10px 25px -3px rgb(0 0 0 / 0.15),\n        0 4px 6px -2px rgb(0 0 0 / 0.05) !important;\n      border: 1px solid rgb(220, 220, 220) !important;\n      background: #ffffff !important;\n      overflow: hidden !important;\n      margin-top: 8px !important;\n      opacity: 0 !important;\n      transform: translateY(-10px) !important;\n      transition:\n        opacity 0.2s ease,\n        transform 0.2s ease !important;\n      visibility: hidden !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__wrapper.is-open {\n      opacity: 1 !important;\n      transform: translateY(0) !important;\n      visibility: visible !important;\n    }\n\n    .pfd-custom-options .t4s-dropdown__content {\n      max-height: 300px !important;\n      overflow-y: auto !important;\n      padding: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item {\n      padding: 0px 8px !important;\n      border: none !important;\n      border-radius: 8px !important;\n      background: #ffffff !important;\n      font-size: 15px !important;\n      cursor: pointer !important;\n      transition: all 0.15s ease !important;\n      font-family: var(--pfd-font-family) !important;\n      color: #333333 !important;\n      margin: 4px !important;\n      height: auto !important;\n      box-shadow: none !important;\n      transform: none !important;\n      font-weight: 500 !important;\n      display: flex !important;\n      width: calc(100% - 8px) !important;\n      text-align: left !important;\n      justify-content: space-between !important;\n      align-items: center !important;\n      position: relative !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:hover {\n      background: #f3f4f6 !important;\n      transform: none !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item:active {\n      transform: none !important;\n      box-shadow: none !important;\n      background: #e5e7eb !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected {\n      background: #f3f4f6 !important;\n      color: #333333 !important;\n      box-shadow: none !important;\n      border-radius: 8px !important;\n    }\n\n    /* Active state for dropdown button when custom option is selected */\n    .pfd-custom-dropdown.is--selected {\n      border-color: var(--pfd-border-color-selected) !important;\n      background: var(--pfd-background) !important;\n      box-shadow:\n        0 0 0 1px rgb(0 0 0 / 0.2),\n        0 1px 2px 0 rgb(0 0 0 / 0.05) !important;\n    }\n\n    .pfd-custom-options .pfd-checkmark {\n      color: #10b981 !important;\n      font-size: 12px !important;\n      font-weight: 600 !important;\n      margin-right: 8px !important;\n      display: inline-block !important;\n      opacity: 0 !important;\n    }\n\n    .pfd-custom-options .t4s-swatch__item.is--selected .pfd-checkmark {\n      opacity: 1 !important;\n    }\n\n    .pfd-custom-options .pfd-option-text {\n      flex: 1 !important;\n      display: inline-block !important;\n    }\n\n    .pfd-custom-options .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 13px !important;\n      font-weight: 500 !important;\n      padding: 4px 8px !important;\n      border-radius: 4px !important;\n      margin-left: 16px !important;\n      display: inline-block !important;\n      flex-shrink: 0 !important;\n      line-height: 10px !important;\n    }\n\n    .pfd-custom-dropdown .pfd-custom-badge {\n      background: #f3e8ff !important;\n      color: #8b5cf6 !important;\n      font-size: 11px !important;\n      font-weight: 500 !important;\n      padding: 2px 6px !important;\n      border-radius: 3px !important;\n      margin-left: 8px !important;\n      display: inline-block !important;\n      vertical-align: middle !important;\n      line-height: 1.2 !important;\n    }\n\n    .pfd-custom-notice {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-notice-content {\n      background: rgba(243, 244, 246, 0.5) !important; /* bg-muted/50 */\n      border: 1px solid #d1d5db !important; /* border-border */\n      border-radius: 8px !important; /* rounded-lg */\n      padding: 12px 16px !important; /* px-4 py-3 */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 12px !important; /* gap-3 */\n    }\n\n    .pfd-custom-notice-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      margin-top: 2px !important; /* mt-0.5 */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-notice-text {\n      font-size: 14px !important; /* text-sm */\n      margin: 0 !important;\n      line-height: 1.4 !important;\n      color: #374151 !important;\n    }\n\n    .pfd-custom-notice-text strong {\n      color: #111827 !important; /* text-foreground */\n      font-weight: 600 !important;\n    }\n\n    .pfd-custom-notice-highlight {\n      font-weight: 600 !important; /* font-semibold */\n      color: #000000 !important; /* black */\n    }\n\n    .pfd-custom-option-info {\n      margin: 16px 0 20px 0 !important;\n      color: var(--pfd-muted-color) !important;\n    }\n\n    .pfd-info-content {\n      color: var(--pfd-muted-color) !important;\n      font-size: 14px !important; /* text-sm */\n      display: flex !important; /* flex */\n      align-items: flex-start !important; /* items-start */\n      gap: 8px !important; /* gap-2 */\n    }\n\n    .pfd-info-icon {\n      flex-shrink: 0 !important; /* shrink-0 */\n      width: 16px !important; /* w-4 */\n      height: 16px !important; /* h-4 */\n      border-radius: 50% !important; /* rounded-full */\n      border: 1px solid rgba(107, 114, 128, 0.3) !important; /* border-muted-foreground/30 */\n      display: flex !important; /* flex */\n      align-items: center !important; /* items-center */\n      justify-content: center !important; /* justify-center */\n      font-size: 12px !important; /* text-xs */\n      margin-top: 2px !important; /* mt-0.5 */\n      font-weight: 500 !important;\n      background: #ffffff !important;\n    }\n\n    .pfd-info-text {\n      line-height: 1.4 !important;\n    }\n\n    .pfd-custom-option-content {\n      margin-top: 12px !important;\n    }\n\n    .pfd-custom-option-content p {\n      margin: 0 !important;\n      font-size: 14px !important;\n      line-height: 1.4 !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right {\n      position: absolute !important;\n      right: 0 !important;\n      top: 0 !important;\n      font-size: 14px !important;\n    }\n\n    .pfd-split-option .t4s-swatch__title--right .bold {\n      font-weight: 600 !important;\n      color: var(--pfd-text-color) !important;\n      font-family: var(--pfd-font-family-weighted) !important;\n    }\n\n    .t4s-swatch__item.swatch-loading,\n    .pfd-standard-options .t4s-swatch__item.swatch-loading {\n      opacity: 0.6 !important;\n      pointer-events: none !important;\n    }\n\n    .t4s-swatch__item.swatch-error,\n    .pfd-standard-options .t4s-swatch__item.swatch-error {\n      background: #f5f5f5 !important;\n      color: var(--pfd-muted-color) !important;\n      border-color: #ddd !important;\n    }\n\n    .t4s-swatch__item:focus,\n    .pfd-standard-options .t4s-swatch__item:focus {\n      outline: 2px solid var(--pfd-border-color-selected) !important;\n      outline-offset: 2px !important;\n    }\n\n    @media (max-width: 1536px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n    }\n\n    @media (max-width: 1080px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n    }\n\n    @media (max-width: 768px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(33% - 6px) !important;\n      }\n\n      .pfd-split-selection {\n        flex-direction: column !important;\n        align-items: flex-start !important;\n        gap: 16px !important;\n      }\n\n      .pfd-standard-options {\n        width: 100% !important;\n      }\n\n      .pfd-or-separator {\n        display: none;\n      }\n\n      .pfd-custom-dropdown {\n        width: 100% !important;\n        min-width: 200px !important;\n      }\n\n      .pfd-or-separator {\n        align-self: center !important;\n        margin: 0 !important;\n      }\n    }\n\n    @media (max-width: 480px) {\n      .t4s-swatch__btn-wrap {\n        width: calc(50% - 4px) !important;\n      }\n\n      .t4s-swatch__item,\n      .pfd-standard-options .t4s-swatch__item {\n        min-width: 45px !important;\n        height: 36px !important;\n        font-size: 13px !important;\n        padding: 0 8px !important;\n      }\n\n      .pfd-split-option .t4s-swatch__title--right {\n        position: static !important;\n        display: block !important;\n      }\n\n      .pfd-custom-dropdown {\n        height: 36px !important;\n        font-size: 13px !important;\n      }\n    }\n  }\n}\n",
              "reasoning": "Fix CSS for available lengths text: allow text wrapping (white-space: normal), strengthen the btn-wrap column layout override withimportant and add .pfd-has-lengths class selector for browsers without :has() support"
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01ELY5QSXiLgiQCruczAd5pg",
            "input": {
              "filePath": "assets/product-form-dynamic.css",
              "startLine": 177,
              "endLine": 230,
              "newContent": ".t4s-swatch__available-lengths {\n  display: none;\n  width: 100%;\n  text-align: center;\n  margin-top: 4px;\n\n  /* Default: muted dark text */\n  color: rgba(0, 0, 0, 0.65);\n\n  font-size: 7px;\n  font-weight: 500;\n  text-transform: uppercase;\n  letter-spacing: 0.3px;\n  white-space: normal;\n  word-break: break-word;\n  pointer-events: none;\n  line-height: 1.3;\n  max-width: 100%;\n}\n\n/* Show when JS adds .is-visible class */\n.t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Content-aware contrast: Light background = dark text */\n[data-luminance=\"light\"] .t4s-swatch__available-lengths {\n  color: rgba(0, 0, 0, 0.65);\n}\n\n/* Content-aware contrast: Dark background = light text */\n[data-luminance=\"dark\"] .t4s-swatch__available-lengths {\n  color: rgba(255, 255, 255, 0.85);\n}\n\n/* ============================================\n   AVAILABLE LENGTHS VISIBILITY CONTROL\n   Element lives as direct child of .t4s-swatch__btn-wrap\n   ============================================ */\n\n/* Hide by default — JS controls visibility via .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths {\n  display: none;\n}\n\n/* Show when JS adds .is-visible */\n.t4s-swatch__btn-wrap > .t4s-swatch__available-lengths.is-visible {\n  display: block;\n}\n\n/* Reflow btn-wrap to column when lengths text is visible.\n   JS also adds .pfd-has-lengths class directly for full browser support. */\n.t4s-swatch__btn-wrap.pfd-has-lengths,\n.t4s-swatch__btn-wrap:has(> .t4s-swatch__available-lengths.is-visible) {\n  display: flex !important;\n  flex-direction: column !important;\n  align-items: center !important;\n  justify-content: center !important;\n}\n",
              "reasoning": "Fix CSS for available lengths text: allow text wrapping (white-space: normal), strengthen the btn-wrap column layout override withimportant and add .pfd-has-lengths class selector for browsers without :has() support"
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772172077758",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n    // Add class to btn-wrap for column layout (supports browsers without :has())\n    if (btnWrap) btnWrap.classList.add(\"pfd-has-lengths\");\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    // Remove column layout class when no lengths to show\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n  }\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Add pfd-has-lengths class to btn-wrap when lengths text is visible, and remove it when hidden. This ensures the column flex layout works in all browsers without relying solely on :has()."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01MjdH95PZb7wvJJgboYYY4L",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 807,
              "endLine": 828,
              "newContent": "  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n    // Add class to btn-wrap for column layout (supports browsers without :has())\n    if (btnWrap) btnWrap.classList.add(\"pfd-has-lengths\");\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    // Remove column layout class when no lengths to show\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n  }\n",
              "reasoning": "Add pfd-has-lengths class to btn-wrap when lengths text is visible, and remove it when hidden. This ensures the column flex layout works in all browsers without relying solely on :has()."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772172085746",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n    // Add class to btn-wrap for column layout (supports browsers without :has())\n    if (btnWrap) btnWrap.classList.add(\"pfd-has-lengths\");\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    // Remove column layout class when no lengths to show\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n  }\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Remove pfd-has-lengths class from btn-wrap when the swatch is no longer sold out, restoring the horizontal inline-flex layout."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01LimsF3KJgHcvHuU4ArdDcm",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 691,
              "endLine": 699,
              "newContent": "    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n",
              "reasoning": "Remove pfd-has-lengths class from btn-wrap when the swatch is no longer sold out, restoring the horizontal inline-flex layout."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "propose_code_edit",
            "id": "pm-change-1772172100325",
            "input": {
              "filePath": "product-form-dynamic.js",
              "newContent": "(() => {\n  /*\n   * Product Form Dynamic (PFD) - Unique Class Names:\n   * - .pfd-variant-images (container for variant image data)\n   * - .pfd-main-imgs (main images container)\n   * - .pfd-thumb-imgs (thumbnail images container)\n   * - .pfd-img-listing (individual variant image listing)\n   * - .pfd-media-item (main image item)\n   * - .pfd-media-thumb (thumbnail item)\n   * - .pfd-img (thumbnail background image div)\n   * - data-pfd-variant-id (variant ID attribute)\n   * - .pfd-split-selection (split selection container)\n   * - .pfd-standard-options (standard swatch options)\n   * - .pfd-custom-options (custom dropdown options)\n   * - .pfd-custom-dropdown (custom dropdown button)\n   */\n\n  // Get custom option names from metafield (passed from Liquid)\n  const CUSTOM_OPTION_NAMES = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  function isCustomOption(optionValue) {\n    // Handle both cleaned (quotes removed) and uncleaned values\n    const cleanedOptionValue = optionValue.replace(/\"/g, \"\");\n    return CUSTOM_OPTION_NAMES.some((customName) => {\n      const cleanedCustomName = customName.replace(/\"/g, \"\");\n      return (\n        optionValue.toLowerCase().includes(customName.toLowerCase()) ||\n        cleanedOptionValue\n          .toLowerCase()\n          .includes(cleanedCustomName.toLowerCase())\n      );\n    });\n  }\n\n  // Check if ANY currently selected option is a custom option\n  // Note: selectedValues is defined later, so this function is used after initialization\n  function hasCustomOptionSelected(selectedValuesArray) {\n    for (const val of selectedValuesArray) {\n      if (val && isCustomOption(val)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Override theme's swatch click handler\n  function setupSwatchOverride() {\n    // Use event capturing to intercept clicks before theme's handler\n    document.addEventListener(\n      \"click\",\n      function (e) {\n        const swatchItem = e.target.closest(\n          \"[data-swatch-item]:not(.is--selected)\",\n        );\n        if (!swatchItem) return;\n\n        // Check if this is within our product form\n        const productForm = swatchItem.closest(\n          \".t4s-product-form__variants, .t4s-form__product\",\n        );\n        if (!productForm) return;\n\n        // Stop the theme's handler from running\n        e.stopImmediatePropagation();\n        e.preventDefault();\n\n        // Let our custom handler process it\n        handleCustomSwatchClick(swatchItem, e);\n      },\n      true,\n    ); // Use capture phase\n  }\n\n  function handleCustomSwatchClick(swatchItem, originalEvent) {\n    const optEl = swatchItem.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Update custom dropdown text if selecting a standard option\n      const value = swatchItem.getAttribute(\"data-value\") || \"\";\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n\n        // Remove active state from dropdown button when standard option is selected\n        const dropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n        if (dropdownButton) {\n          dropdownButton.classList.remove(\"is--selected\");\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    // Always add selected class to the clicked item\n    swatchItem.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const value = swatchItem.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(value, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = swatchItem.closest(\".pfd-custom-options\");\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n      // Add active state to dropdown button\n      if (customDropdownButton) {\n        customDropdownButton.classList.add(\"is--selected\");\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n      // Remove active state from dropdown button when standard option is selected\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n      if (customDropdownButton) {\n        customDropdownButton.classList.remove(\"is--selected\");\n      }\n    }\n\n    // Update our internal state if PFD is initialized\n    if (window.__PFD && window.__PFD.selectedValues) {\n      window.__PFD.selectedValues[optionIndex] = normVal(value);\n\n      // Resolve variant and update select\n      const variantId = resolveVariantFromValues(window.__PFD.selectedValues);\n      if (variantId && window.__PFD.selectEl) {\n        // Update HTML data attributes with correct variant info before changing select\n        const variant = window.__PFD.variantById.get(variantId);\n        if (variant) {\n          const selectedOption = window.__PFD.selectEl.querySelector(\n            `option[value=\"${variantId}\"]`,\n          );\n          if (selectedOption) {\n            // Update HTML data attributes that the theme actually checks\n            selectedOption.setAttribute(\n              \"data-incoming\",\n              variant.incoming || \"false\",\n            );\n            selectedOption.setAttribute(\n              \"data-nextincomingdate\",\n              variant.nextIncomingDate || \"\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventorypolicy\",\n              variant.inventoryPolicy || \"deny\",\n            );\n            selectedOption.setAttribute(\n              \"data-inventoryquantity\",\n              variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n            );\n          }\n        }\n\n        window.__PFD.selectEl.value = variantId;\n        window.__PFD.selectEl.dispatchEvent(\n          new Event(\"change\", { bubbles: true }),\n        );\n      }\n\n      // Update availability\n      if (typeof patchAllAvailability === \"function\") {\n        patchAllAvailability();\n      }\n    } else {\n      // Fallback: find the select and update it directly\n      const form = swatchItem.closest(\"form, .t4s-form__product\");\n      const selectEl = form?.querySelector('select[name=\"id\"]');\n      if (selectEl) {\n        // Get all selected values and find matching variant\n        const allOptions = form.querySelectorAll(\"[data-swatch-option]\");\n        const selectedValues = [];\n\n        allOptions.forEach((opt) => {\n          const idx = Number(opt.getAttribute(\"data-id\"));\n          const selected = opt.querySelector(\"[data-swatch-item].is--selected\");\n          selectedValues[idx] = selected\n            ? normVal(selected.getAttribute(\"data-value\") || \"\")\n            : \"\";\n        });\n\n        // Find matching option in select\n        const options = selectEl.querySelectorAll(\"option\");\n        for (const option of options) {\n          const optionMatches = selectedValues.every((val, idx) => {\n            if (!val) return true;\n            const optionVal =\n              option.getAttribute(`data-option${idx + 1}`) || \"\";\n            return normVal(optionVal) === val;\n          });\n\n          if (optionMatches) {\n            selectEl.value = option.value;\n            selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n            break;\n          }\n        }\n      }\n    }\n\n    // Manually trigger the thumbnail update functionality that the theme expects\n    // This replicates the jQuery code from main-product.liquid lines 5489+\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 100);\n    }\n  }\n\n  // Manual thumbnail update function to maintain existing functionality\n  function triggerThumbnailUpdate() {\n    if (typeof $ === \"undefined\") return;\n\n    // Remove existing slick script to avoid conflicts\n    $(\n      'head script[src=\"https://kenwheeler.github.io/slick/slick/slick.js\"]',\n    ).remove();\n\n    setTimeout(function () {\n      var sel_var_id = $(\n        '.t4s-product-form__variants select[name=\"id\"] option:selected',\n      ).val();\n\n      if (!sel_var_id) {\n        return;\n      }\n\n      var sel_images = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var sel_thumb_img = $(\n        \".pfd-variant-images .pfd-thumb-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).html();\n      var data_var_img = $(\n        \".pfd-variant-images .pfd-main-imgs .pfd-img-listing[data-pfd-variant-id='\" +\n          sel_var_id +\n          \"']\",\n      ).attr(\"data-var-img\");\n\n      // Check if we have variant images or just a single image\n      var mediaItemCount = 0;\n      if (sel_images && sel_images.trim() !== \"\") {\n        mediaItemCount = $(sel_images).filter(\".pfd-media-item\").length;\n      }\n\n      var hasMultipleImages = mediaItemCount > 1;\n\n      if (!hasMultipleImages) {\n        // Show single image or fallback\n        $(\".t4s-product__media-wrapper .slider_sec_main\")\n          .show()\n          .css(\"opacity\", \"1\");\n        if (data_var_img) {\n          $(\".slider_sec_main\").html(\"<img src='\" + data_var_img + \"' />\");\n        }\n        $(\".slick_gallery\").hide();\n      } else {\n        // Show gallery with multiple images\n        $(\".slick_gallery\").css(\"opacity\", \"0\");\n        $(\".t4s-product__media-wrapper .slider_sec_main\").hide();\n        $(\".slick_gallery\").show();\n        $(\n          \".t4s-product__media-wrapper .t4s-col-thumb .t4s-carousel__nav\",\n        ).hide();\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_for\").html(\n          sel_images,\n        );\n        $(\".t4s-product__media-wrapper .slick_gallery .slider_nav\").html(\n          sel_thumb_img,\n        );\n        $(\".slick-initialized\").removeClass(\"slick-initialized\");\n        $(\".slick-slider\").removeClass(\"slick-slider\");\n        $(\".slick-vertical\").removeClass(\"slick-vertical\");\n\n        var s = document.createElement(\"script\");\n        s.type = \"text/javascript\";\n        s.src = \"https://kenwheeler.github.io/slick/slick/slick.js\";\n        $(\"head\").append(s);\n\n        setTimeout(function () {\n          $(\".slick_gallery .slider_for\").slick({\n            slidesToShow: 1,\n            slidesToScroll: 1,\n            arrows: true,\n            fade: true,\n            adaptiveHeight: true,\n            asNavFor: \".slider_nav\",\n          });\n          $(\".slick_gallery .slider_nav\").slick({\n            slidesToShow: 7,\n            slidesToScroll: 1,\n            vertical: true,\n            asNavFor: \".slider_for\",\n            dots: false,\n            adaptiveHeight: true,\n            focusOnSelect: true,\n            verticalSwiping: true,\n            responsive: [\n              {\n                breakpoint: 1400,\n                settings: {\n                  slidesToShow: 5,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 767,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n              {\n                breakpoint: 480,\n                settings: {\n                  verticalSwiping: false,\n                  vertical: false,\n                  slidesToShow: 4,\n                  slidesToScroll: 1,\n                },\n              },\n            ],\n          });\n\n          $(\".slick_gallery\").css(\"opacity\", \"1\");\n        }, 100);\n      }\n    }, 100);\n  }\n\n  // Initialize swatch override immediately\n  setupSwatchOverride();\n\n  const root = document.querySelector(\".t4s-product-form__variants\");\n  if (!root) return;\n\n  const selectEl = root.querySelector('select[name=\"id\"]');\n  const variantsJsonEl = root.querySelector(\"script.pr_variants_json\");\n  const optionsJsonEl = root.querySelector(\"script.pr_options_json\");\n\n  if (!selectEl || !variantsJsonEl || !optionsJsonEl) {\n    console.warn(\"[PFD] Missing required elements\");\n    return;\n  }\n\n  const normName = (s) =>\n    String(s ?? \"\")\n      .trim()\n      .toLowerCase();\n  const normVal = (s) => String(s ?? \"\").trim();\n  const keyFromValues = (values) => values.map(normVal).join(\"||\");\n\n  // Helper function to get display value (only strips quotes for display purposes)\n  const getDisplayValue = (rawValue, optionUnit = \"\") => {\n    const cleanedValue = rawValue.replace(/\"/g, \"\");\n    return optionUnit ? `${cleanedValue} ${optionUnit}` : cleanedValue;\n  };\n\n  const getSwatchOptions = () => [\n    ...root.querySelectorAll(\"[data-swatch-option]\"),\n  ];\n\n  const getSwatchItems = (optionIndex) => {\n    const optEl = getSwatchOptions().find(\n      (el) => Number(el.getAttribute(\"data-id\")) === optionIndex,\n    );\n    if (!optEl) return { optEl: null, items: [] };\n    return {\n      optEl,\n      items: [...optEl.querySelectorAll(\"[data-swatch-item]\")],\n    };\n  };\n\n  // ----- parse bootstrap -----\n  let initialVariants = [];\n  let options = [];\n\n  try {\n    initialVariants = JSON.parse(variantsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_variants_json\", e);\n  }\n\n  try {\n    options = JSON.parse(optionsJsonEl.textContent || \"[]\");\n  } catch (e) {\n    console.warn(\"[PFD] Bad pr_options_json\", e);\n  }\n\n  const optionCount = Math.max(1, options.length || 0);\n\n  // ----- state -----\n  // Build maps from BOTH theme JSON and Storefront hydration (same shape)\n  const variantById = new Map(); // id -> {id, available, option1..N}\n  const idByKey = new Map(); // \"v1||v2||v3\" -> id\n  const selectedValues = Array(optionCount).fill(\"\");\n\n  // Initialize theme variant array reference\n  if (!window.__PFD_VARIANTS__) {\n    window.__PFD_VARIANTS__ = [];\n  }\n\n  // Keep debug available and expose select element\n  window.__PFD = { variantById, idByKey, selectedValues, options, selectEl };\n\n  function resolveVariantFromValues(selectedValues) {\n    if (!idByKey || !selectedValues) return null;\n    return idByKey.get(keyFromValues(selectedValues));\n  }\n\n  function upsertVariant(v) {\n    const id = String(v.id);\n    variantById.set(id, v);\n    if (id === \"51236621975869\") {\n      console.log(\"HERE\", variantById.get(id));\n    }\n\n    const values = [];\n    for (let i = 0; i < optionCount; i++)\n      values.push(v[`option${i + 1}`] ?? \"\");\n    idByKey.set(keyFromValues(values), id);\n\n    // Update theme's variant array\n    updateThemeVariantArray(v, v._productRequiresSellingPlan);\n  }\n\n  // Function to build theme-compatible variant object\n  function buildThemeVariant(rawVariant, productRequiresSellingPlan = false) {\n    // If variant already has full theme data, preserve it and just add PFD fields\n    if (rawVariant.title && rawVariant.name && rawVariant.public_title) {\n      return {\n        ...rawVariant, // Preserve all existing theme fields\n        // Ensure PFD-specific fields are included\n        imageUrl: rawVariant.imageUrl,\n        variantImages: rawVariant.variantImages || [],\n      };\n    }\n\n    // For variants that need theme format building\n    const optionValues = [\n      rawVariant.option1,\n      rawVariant.option2,\n      rawVariant.option3,\n    ].filter(Boolean);\n    const titleFromOptions = optionValues.join(\" / \");\n\n    return {\n      id: Number(rawVariant.id),\n      title: rawVariant.title || titleFromOptions,\n      option1: rawVariant.option1 || null,\n      option2: rawVariant.option2 || null,\n      option3: rawVariant.option3 || null,\n      sku: rawVariant.sku || null,\n      requires_shipping: rawVariant.requires_shipping !== false,\n      taxable: rawVariant.taxable !== false,\n      featured_image:\n        rawVariant.featured_image ||\n        (rawVariant.imageUrl ? { src: rawVariant.imageUrl } : null),\n      available: rawVariant.available,\n      name: rawVariant.name || rawVariant.title || titleFromOptions,\n      public_title: rawVariant.public_title || titleFromOptions,\n      options: rawVariant.options || optionValues,\n      price: rawVariant.price || 0,\n      weight: rawVariant.weight || 0,\n      compare_at_price: rawVariant.compare_at_price || null,\n      inventory_management: rawVariant.inventory_management || \"shopify\",\n      barcode: rawVariant.barcode || \"\",\n      featured_media: rawVariant.featured_media || null,\n      requires_selling_plan:\n        rawVariant.requires_selling_plan !== undefined\n          ? rawVariant.requires_selling_plan\n          : productRequiresSellingPlan,\n      selling_plan_allocations: rawVariant.selling_plan_allocations || [],\n      quantity_rule: rawVariant.quantity_rule || {\n        min: 1,\n        max: null,\n        increment: 1,\n      },\n      incoming: rawVariant.incoming || false,\n      next_incoming_date: rawVariant.next_incoming_date || null,\n      inventory_policy: rawVariant.inventory_policy || null,\n      inventory_quantity: rawVariant.inventory_quantity || 0,\n      // Preserve PFD-specific data\n      imageUrl: rawVariant.imageUrl,\n      variantImages: rawVariant.variantImages || [],\n    };\n  }\n\n  // Function to populate theme's variant array with variant data\n  function updateThemeVariantArray(\n    variant,\n    productRequiresSellingPlan = false,\n  ) {\n    if (!window.__PFD_VARIANTS__) {\n      window.__PFD_VARIANTS__ = [];\n    }\n\n    const existingIndex = window.__PFD_VARIANTS__.findIndex(\n      (v) => String(v.id) === String(variant.id),\n    );\n\n    const themeVariant = buildThemeVariant(variant, productRequiresSellingPlan);\n\n    if (existingIndex >= 0) {\n      // Update existing variant\n      window.__PFD_VARIANTS__[existingIndex] = themeVariant;\n    } else {\n      // Add new variant\n      window.__PFD_VARIANTS__.push(themeVariant);\n    }\n  }\n\n  for (const v of initialVariants) {\n    // Extract image URL from variant data\n    let imageUrl = null;\n    if (v.featured_image && v.featured_image.src) {\n      imageUrl = v.featured_image.src;\n    } else if (\n      v.featured_media &&\n      v.featured_media.preview_image &&\n      v.featured_media.preview_image.src\n    ) {\n      imageUrl = v.featured_media.preview_image.src;\n    }\n\n    // Preserve all existing theme variant data and add PFD-specific fields\n    upsertVariant({\n      ...v,\n      available: !!v.available,\n      imageUrl: imageUrl,\n      variantImages: imageUrl ? [imageUrl] : [],\n    });\n  }\n\n  function getSelectedFromDOM() {\n    const values = Array(optionCount).fill(\"\");\n    for (const optEl of getSwatchOptions()) {\n      const idx = Number(optEl.getAttribute(\"data-id\"));\n      if (Number.isNaN(idx)) continue;\n\n      const selectedItem = optEl.querySelector(\n        \"[data-swatch-item].is--selected\",\n      );\n      if (selectedItem)\n        values[idx] = normVal(selectedItem.getAttribute(\"data-value\") || \"\");\n    }\n    return values;\n  }\n\n  function resolveVariantId(values) {\n    return idByKey.get(keyFromValues(values));\n  }\n\n  // IMPORTANT: do NOT dispatch change unless variant truly changed\n  let lastAppliedVariantId = null;\n  function applyVariantToSelect(variantId) {\n    if (!variantId) return;\n    const nextId = String(variantId);\n    if (lastAppliedVariantId === nextId) return;\n\n    lastAppliedVariantId = nextId;\n    selectEl.value = nextId;\n\n    // Ensure DOM exists for this variant before theme processes it\n    ensureDOMForVariant(nextId);\n\n    // Let theme update its own UI\n    selectEl.dispatchEvent(new Event(\"change\", { bubbles: true }));\n  }\n\n  // Progressive prefix matching for availability\n  function variantMatchesPrefix(v, optionIndex) {\n    for (let i = 0; i < optionIndex; i++) {\n      const sel = normVal(selectedValues[i]);\n      if (!sel) continue;\n      if (normVal(v[`option${i + 1}`] ?? \"\") !== sel) return false;\n    }\n    return true;\n  }\n\n  // Visual \"sold out marker\" handling:\n  // We only toggle the visual class but keep items clickable\nfunction setSoldOut(el, isSoldOut) {\n  el.classList.toggle(\"is--soldout\", isSoldOut);\n  el.classList.toggle(\"is--out-of-stock\", isSoldOut);\n\n  // Find the correct parent for the badge (image container if exists)\n  const imgContainer = el.querySelector(\"[data-img-el]\");\n  const badgeParent = imgContainer || el;\n\n  if (isSoldOut) {\n    el.setAttribute(\"aria-disabled\", \"true\");\n    el.dataset.available = \"false\";\n\n    // Create badge if doesn't exist\n    let badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (!badge) {\n      badge = document.createElement(\"span\");\n      badge.className = \"t4s-swatch__restock-badge\";\n      badge.textContent = \"Awaiting Restock\";\n      badgeParent.appendChild(badge);\n\n      // Run luminance detection if inside image container\n      if (imgContainer) {\n        detectSwatchLuminance(imgContainer, badge);\n      }\n    }\n    // Class-based visibility (works with CSS !important)\n    badge.classList.add(\"is-visible\");\n\n    // Compute and show available standard this color\n    updateAvailableLengths(el, badgeParent, imgContainer);\n  } else {\n    el.removeAttribute(\"aria-disabled\");\n    el.dataset.available = \"true\";\n\n    // Find and hide badge\n    const badge = badgeParent.querySelector(\".t4s-swatch__restock-badge\");\n    if (badge) {\n      badge.classList.remove(\"is-visible\");\n    }\n\n    // Hide available lengths (lives as sibling in btn-wrap)\n    const btnWrap = el.parentNode;\n    const lengthsEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : el.querySelector(\".t4s-swatch__available-lengths\");\n    if (lengthsEl) {\n      lengthsEl.classList.remove(\"is-visible\");\n    }\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n\n  }\n}\n\nfunction updateAvailableLengths(swatchEl, badgeParent, imgContainer) {\n  const customNames = window.__CUSTOM_OPTION_NAMES__ || [];\n\n  // Find which option index is the color option\n  let colorOptIdx = -1;\n  for (let i = 0; i < optionCount; i++) {\n    if (isColorOption(i)) {\n      colorOptIdx = i;\n      break;\n    }\n  }\n  if (colorOptIdx < 0) return;\n\n  // Get the color value from this swatch element\n  const colorValue = normVal(swatchEl.getAttribute(\"data-value\") || \"\");\n  if (!colorValue) return;\n\n  // Identify all non-color option indices\n  const nonColorIndices = [];\n  for (let i = 0; i < optionCount; i++) {\n    if (i !== colorOptIdx) nonColorIndices.push(i);\n  }\n  if (nonColorIndices.length === 0) return;\n\n  // For each non-color option, collect the currently\n  // (these are the selections that are out-of-stock for this color)\n  const currentSelections = nonColorIndices.map((idx) =>\n    normVal(selectedValues[idx] || \"\")\n  );\n\n  // Check if this color IS available at the current non-color selections.\n  // If so, there's nothing to report — hide any existing text and bail.\n  const availableAtCurrentSelections = [...variantById.values()].some((v) => {\n    if (!v || !v.available) return false;\n    const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n    if (vColor !== colorValue) return false;\n    return nonColorIndices.every((idx, i) => {\n      const sel = currentSelections[i];\n      if (!sel) return true; // no selection yet — don't filter\n      return normVal(v[`option${idx + 1}`] || \"\") === sel;\n    });\n  });\n\n  if (availableAtCurrentSelections) {\n    const btnWrap = swatchEl.parentNode;\n    const existingEl = btnWrap\n      ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n      : null;\n    if (existingEl) existingEl.classList.remove(\"is-visible\");\n    return;\n  }\n\n  // For each non-color option, collect the available values for this color.\n  // We exclude the currently selected value for that option (it's the out-of-stock one)\n  // and skip custom option values.\n  const availableByOption = nonColorIndices.map((idx, i) => {\n    const currentSel = currentSelections[i];\n    const seen = new Set();\n    const values = [];\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n      const vColor = normVal(v[`option${colorOptIdx + 1}`] || \"\");\n      if (vColor !== colorValue) continue;\n\n      const rawVal = v[`option${idx + 1}`] || \"\";\n      if (!rawVal) continue;\n\n      // Skip custom option values\n      const isCustom = customNames.some(\n        (cn) => String(cn).trim() === String(rawVal).trim()\n      );\n      if (isCustom) continue;\n\n      const cleanVal = String(rawVal).replace(/\"/g, \"\");\n\n      // Skip the currently selected value for this option — it's the out-of-stock one\n      if (currentSel && normVal(cleanVal) === currentSel) continue;\n\n      if (!seen.has(cleanVal)) {\n        seen.add(cleanVal);\n        values.push(cleanVal);\n      }\n    }\n\n    return { idx, values };\n  });\n\n  // Build the display text: collect all available values across all non-color options\n  // If there's only one non-color option, just list its values.\n  // If there are multiple, prefix each group with the option name.\n  const parts = [];\n  for (const { idx, values } of availableByOption) {\n    if (values.length === 0) continue;\n    if (nonColorIndices.length === 1) {\n      // Single non-color option — no need for a label prefix\n      parts.push(values.join(\", \"));\n    } else {\n      // Multiple non-color options — prefix with the option name for clarity\n      const optName = (options?.[idx]?.name || \"\").replace(/\"/g, \"\");\n      parts.push(optName ? `${optName}: ${values.join(\", \")}` : values.join(\", \"));\n    }\n  }\n\n  // The lengths element lives as a direct child of .t4s-swatch__btn-wrap\n  const btnWrap = swatchEl.parentNode;\n  let lengthsEl = btnWrap\n    ? btnWrap.querySelector(\":scope > .t4s-swatch__available-lengths\")\n    : null;\n\n  if (parts.length > 0) {\n    if (!lengthsEl) {\n      lengthsEl = document.createElement(\"span\");\n      lengthsEl.className = \"t4s-swatch__available-lengths\";\n      if (btnWrap) {\n        btnWrap.appendChild(lengthsEl);\n      } else {\n        swatchEl.appendChild(lengthsEl);\n      }\n    }\n    lengthsEl.textContent = \"In: \" + parts.join(\" · \");\n    lengthsEl.classList.add(\"is-visible\");\n    // Add class to btn-wrap for column layout (supports browsers without :has())\n    if (btnWrap) btnWrap.classList.add(\"pfd-has-lengths\");\n  } else {\n    if (lengthsEl) lengthsEl.classList.remove(\"is-visible\");\n    // Remove column layout class when no lengths to show\n    if (btnWrap) btnWrap.classList.remove(\"pfd-has-lengths\");\n  }\n}\n\n// Luminance detection for content-aware badge contrast\nconst luminanceCache = new Map();\n\nfunction detectSwatchLuminance(imgContainer, badge) {\n  const img = imgContainer.querySelector(\"img\");\n  if (!img || !img.src || img.src === \"\" || img.src === \"null\") {\n    console.log(\"[Luminance] No valid image found, defaulting to dark\");\n    imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    return;\n  }\n\n  // Check cache first\n  if (luminanceCache.has(img.src)) {\n    const cached = luminanceCache.get(img.src);\n    console.log(\"[Luminance] Using cached result:\", cached, \"for\", img.src.split(\"/\").pop());\n    imgContainer.setAttribute(\"data-luminance\", cached);\n    return;\n  }\n\n  // Wait for image to load if needed\n  const analyze = () => {\n    try {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      canvas.width = 20;\n      canvas.height = 20;\n\n      ctx.drawImage(img, 0, 0, 20, 20);\n      const imageData = ctx.getImageData(0, 0, 20, 20).data;\n\n      let totalLuminance = 0;\n      const pixelCount = imageData.length / 4;\n\n      for (let i = 0; i < imageData.length; i += 4) {\n        // Perceived luminance formula: 0.299R + 0.587G + 0.114B\n        const luminance = 0.299 * imageData[i] + 0.587 * imageData[i + 1] + 0.114 * imageData[i + 2];\n        totalLuminance += luminance;\n      }\n\n      const avgLuminance = totalLuminance / pixelCount;\n      const result = avgLuminance > 128 ? \"light\" : \"dark\";\n\n      // DEBUG: Log the calculation results\n      console.log(\"[Luminance] Image:\", img.src.split(\"/\").pop(), \"| Avg:\", avgLuminance.toFixed(1), \"| Result:\", result);\n\n      luminanceCache.set(img.src, result);\n      imgContainer.setAttribute(\"data-luminance\", result);\n    } catch (e) {\n      // DEBUG: Log CORS or other errors\n      console.error(\"[Luminance] Error analyzing image:\", e.message, \"| Image:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }\n  };\n\n  if (img.complete && img.naturalWidth > 0) {\n    analyze();\n  } else {\n    img.addEventListener(\"load\", analyze, { once: true });\n    img.addEventListener(\"error\", () => {\n      console.error(\"[Luminance] Image failed to load:\", img.src);\n      imgContainer.setAttribute(\"data-luminance\", \"dark\");\n    }, { once: true });\n  }\n}\n\n// Check if an option is a Color option based on the option name\nfunction isColorOption(optionIndex) {\n  const optionName = normName(options?.[optionIndex]?.name || \"\");\n  return optionName === \"color\" || optionName === \"colour\";\n}\n\n// Find variant matching current selections + given color value\nfunction getVariantForColorValue(colorValue, currentSelection, colorIndex) {\n  for (const v of variantById.values()) {\n    if (!v) continue;\n\n    const variantColorVal = normVal(v[`option${colorIndex + 1}`] || \"\");\n    if (variantColorVal !== colorValue) continue;\n\n    let matches = true;\n    for (let i = 0; i < optionCount; i++) {\n      if (i === colorIndex) continue;\n      const selectedVal = normVal(currentSelection[i] || \"\");\n      const variantVal = normVal(v[`option${i + 1}`] || \"\");\n      if (selectedVal && selectedVal !== variantVal) {\n        matches = false;\n        break;\n      }\n    }\n\n    if (matches) return v;\n  }\n  return null;\n}\n\nfunction patchAvailabilityForOption(optionIndex) {\n  const { items } = getSwatchItems(optionIndex);\n  if (!items.length) return;\n\n  const availableByValue = new Map();\n  const isColor = isColorOption(optionIndex);\n\n  // Use selectedValues array directly instead of reading from DOM\n  // This ensures we have the most up-to-date selection state\n  // (especially important after click handlers update selectedValues)\n  const currentSelection = [...selectedValues];\n\n  if (isColor) {\n    // For Color options: only show sold-out if the specific combination is sold out\n\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      // Check if variant matches all currently selected options\n      let matches = true;\n      for (let i = 0; i < optionCount; i++) {\n        // Ignore the current option being evaluated\n        if (i === optionIndex) continue;\n\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option with current selections\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n\n      let matches = true;\n      for (let i = 0; i < optionIndex; i++) {\n        const selectedVal = normVal(currentSelection[i] || \"\");\n        const variantVal = normVal(v[`option${i + 1}`] || \"\");\n        if (selectedVal && selectedVal !== variantVal) {\n          matches = false;\n          break;\n        }\n      }\n\n      if (!matches) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  } else {\n    // For non-Color options: only show sold-out if ALL variants with that value are sold out\n    for (const v of variantById.values()) {\n      if (!v || !v.available) continue;\n\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      if (val) availableByValue.set(val, true);\n    }\n\n    // Check if we have any variants for this option at all\n    const hasAnyVariantsForOption = [...variantById.values()].some((v) => {\n      if (!v) return false;\n      const val = normVal(v[`option${optionIndex + 1}`] ?? \"\");\n      return !!val;\n    });\n\n    if (!hasAnyVariantsForOption) {\n      for (const item of items) setSoldOut(item, false);\n      return;\n    }\n  }\n\n  let availableCount = 0;\n  let soldOutCount = 0;\n\n  for (const item of items) {\n    const val = normVal(item.getAttribute(\"data-value\") || \"\");\n    const isAvailable = availableByValue.get(val) === true;\n\n    if (isColor && !isAvailable && hasCustomOptionSelected(currentSelection)) {\n      // Check if variant is truly unavailable (not just out of stock)\n      const variant = getVariantForColorValue(val, currentSelection, optionIndex);\n      if (variant && variant.inventory_quantity <= 0 && !variant.available) {\n        // Hide completely for custom options\n        item.classList.add('pfd-hidden-custom');\n        item.style.display = 'none';\n        continue;\n      }\n    }\n\n    // Show the swatch (remove hidden state if previously hidden)\n    item.classList.remove('pfd-hidden-custom');\n    item.style.display = '';\n\n    setSoldOut(item, !isAvailable);\n\n    if (isAvailable) {\n      availableCount++;\n    } else {\n      soldOutCount++;\n    }\n  }\n}\n\n  function patchAllAvailability() {\n    // Sync selectedValues with current DOM state before patching availability\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = domSelected[i];\n    }\n\n    for (let i = 0; i < optionCount; i++) patchAvailabilityForOption(i);\n  }\n\n  function updateSwatchImages() {\n    // Update swatch items with variant image data\n    const swatchItems = root.querySelectorAll(\"[data-swatch-item]\");\n\n    for (const item of swatchItems) {\n      const optionEl = item.closest(\"[data-swatch-option]\");\n      if (!optionEl) continue;\n\n      const optionIndex = Number(optionEl.getAttribute(\"data-id\"));\n      const itemValue = normVal(item.getAttribute(\"data-value\") || \"\");\n\n      if (Number.isNaN(optionIndex) || !itemValue) continue;\n\n      // Find variants that match this option value at this position\n      const matchingVariants = [...variantById.values()].filter((v) => {\n        const variantValue = normVal(v[`option${optionIndex + 1}`] || \"\");\n        return variantValue === itemValue;\n      });\n\n      // Use the first matching variant's image (prioritizing available variants)\n      const preferredVariant =\n        matchingVariants.find((v) => v.available && v.imageUrl) ||\n        matchingVariants.find((v) => v.imageUrl);\n\n      const imgEl =\n        item.querySelector(\"[data-img-el] img\") || item.querySelector(\"img\");\n      if (imgEl) {\n        if (preferredVariant && preferredVariant.imageUrl) {\n          item.setAttribute(\"data-var-img\", preferredVariant.imageUrl);\n          setupSwatchImageLoad(imgEl, preferredVariant.imageUrl, item);\n        } else {\n          // No image available, show placeholder\n          item.classList.add(\"swatch-placeholder\");\n          imgEl.src = \"\";\n        }\n      }\n    }\n  }\n\n  function setupSwatchImageLoad(imgEl, imageUrl, swatchItem) {\n    // Add loading state\n    swatchItem.classList.add(\"swatch-loading\");\n    swatchItem.classList.remove(\n      \"swatch-loaded\",\n      \"swatch-error\",\n      \"swatch-placeholder\",\n    );\n\n    // Handle load success\n    imgEl.onload = function () {\n      swatchItem.classList.remove(\"swatch-loading\", \"swatch-placeholder\");\n      swatchItem.classList.add(\"swatch-loaded\");\n    };\n\n    // Handle load error\n    imgEl.onerror = function () {\n      swatchItem.classList.remove(\"swatch-loading\");\n      swatchItem.classList.add(\"swatch-error\", \"swatch-placeholder\");\n      imgEl.src = \"\";\n    };\n\n    // Set the image source to trigger loading\n    imgEl.src = imageUrl;\n  }\n\n  function updateVariantImages() {\n    // Hide any legacy variant image containers to ensure only our implementation is used\n    const legacyContainers = root.querySelectorAll(\".varin_imgaes\");\n    legacyContainers.forEach((container) => {\n      container.style.display = \"none !important\";\n    });\n\n    // Update the .pfd-variant-images sections with correct variant image data\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    let createdCount = 0;\n    let updatedCount = 0;\n\n    // Process all variants in our map\n    for (const [variantId, variant] of variantById.entries()) {\n      if (!variant) continue;\n\n      // Handle main images\n      if (mainImgsEl) {\n        let mainListing = mainImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create main listing if it doesn't exist\n        if (!mainListing) {\n          mainListing = document.createElement(\"div\");\n          mainListing.className = \"pfd-img-listing\";\n          mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n          mainImgsEl.appendChild(mainListing);\n          createdCount++;\n\n          // Populate with images only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        } else {\n          // Update existing DOM element with hydrated image data\n          updatedCount++;\n\n          // Clear existing content and repopulate with hydrated data\n          mainListing.innerHTML = \"\";\n          mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaItem = document.createElement(\"div\");\n            mediaItem.className = \"pfd-media-item\";\n            const img = document.createElement(\"img\");\n            img.src = imageUrl;\n            mediaItem.appendChild(img);\n            mainListing.appendChild(mediaItem);\n          }\n        }\n      }\n\n      // Handle thumbnail images\n      if (thumbImgsEl) {\n        let thumbListing = thumbImgsEl.querySelector(\n          `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n        );\n\n        // Create thumb listing if it doesn't exist (for hydrated variants)\n        if (!thumbListing) {\n          thumbListing = document.createElement(\"div\");\n          thumbListing.className = \"pfd-img-listing\";\n          thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n          thumbImgsEl.appendChild(thumbListing);\n\n          // Populate with thumbnails only when creating new\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        } else {\n          // Update existing thumb DOM element with hydrated image data\n\n          // Clear existing content and repopulate with hydrated data\n          thumbListing.innerHTML = \"\";\n\n          const imagesToUse =\n            variant.variantImages && variant.variantImages.length > 0\n              ? variant.variantImages\n              : variant.imageUrl\n                ? [variant.imageUrl]\n                : [];\n\n          for (const imageUrl of imagesToUse) {\n            const mediaThumb = document.createElement(\"div\");\n            mediaThumb.className = \"pfd-media-thumb\";\n            const imgDiv = document.createElement(\"div\");\n            imgDiv.className = \"pfd-img\";\n            imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n            mediaThumb.appendChild(imgDiv);\n            thumbListing.appendChild(mediaThumb);\n          }\n        }\n      }\n    }\n  }\n\n  // Listen for variant changes to ensure DOM is updated\n  function ensureDOMForVariant(variantId) {\n    const variant = variantById.get(variantId);\n    if (!variant || !variant.variantImages) return;\n\n    const varinImagesEl = root.querySelector(\".pfd-variant-images\");\n    if (!varinImagesEl) return;\n\n    const mainImgsEl = varinImagesEl.querySelector(\".pfd-main-imgs\");\n    const thumbImgsEl = varinImagesEl.querySelector(\".pfd-thumb-imgs\");\n\n    // Ensure main listing exists\n    if (mainImgsEl) {\n      let mainListing = mainImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!mainListing) {\n        mainListing = document.createElement(\"div\");\n        mainListing.className = \"pfd-img-listing\";\n        mainListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        mainListing.setAttribute(\"data-var-img\", variant.imageUrl || \"\");\n        mainImgsEl.appendChild(mainListing);\n\n        // Populate with images\n        for (const imageUrl of variant.variantImages) {\n          const mediaItem = document.createElement(\"div\");\n          mediaItem.className = \"pfd-media-item\";\n          const img = document.createElement(\"img\");\n          img.src = imageUrl;\n          mediaItem.appendChild(img);\n          mainListing.appendChild(mediaItem);\n        }\n      }\n    }\n\n    // Ensure thumb listing exists\n    if (thumbImgsEl) {\n      let thumbListing = thumbImgsEl.querySelector(\n        `.pfd-img-listing[data-pfd-variant-id=\"${variantId}\"]`,\n      );\n\n      if (!thumbListing) {\n        thumbListing = document.createElement(\"div\");\n        thumbListing.className = \"pfd-img-listing\";\n        thumbListing.setAttribute(\"data-pfd-variant-id\", variantId);\n        thumbImgsEl.appendChild(thumbListing);\n\n        // Populate with thumbnails\n        for (const imageUrl of variant.variantImages) {\n          const mediaThumb = document.createElement(\"div\");\n          mediaThumb.className = \"pfd-media-thumb\";\n          const imgDiv = document.createElement(\"div\");\n          imgDiv.className = \"pfd-img\";\n          imgDiv.style.backgroundImage = `url('${imageUrl}')`;\n          mediaThumb.appendChild(imgDiv);\n          thumbListing.appendChild(mediaThumb);\n        }\n      }\n    }\n  }\n\n  // Ensure select option exists for hydrated variants\n  function ensureSelectOption(variantId, variant) {\n    if (selectEl.querySelector(`option[value=\"${variantId}\"]`)) return;\n\n    const option = document.createElement(\"option\");\n    option.value = variantId;\n    option.setAttribute(\"data-option1\", variant.option1 || \"\");\n    option.setAttribute(\"data-option2\", variant.option2 || \"\");\n\n    const optionValues = [\n      variant.option1,\n      variant.option2,\n      variant.option3,\n    ].filter(Boolean);\n    option.textContent = optionValues.join(\" / \");\n\n    if (!variant.available) option.disabled = true;\n\n    selectEl.appendChild(option);\n  }\n\n  // ---------- PFD Click handling (backup for our override) ----------\n  function handlePFDSwatchClick(item) {\n    const optEl = item.closest(\"[data-swatch-option]\");\n    if (!optEl) return;\n\n    const optionIndex = Number(optEl.getAttribute(\"data-id\"));\n    if (Number.isNaN(optionIndex)) return;\n\n    // preserve current selections (prevents \"reset to 14\")\n    const domSelected = getSelectedFromDOM();\n    for (let i = 0; i < optionCount; i++) {\n      if (!selectedValues[i] && domSelected[i])\n        selectedValues[i] = domSelected[i];\n    }\n\n    const value = normVal(item.getAttribute(\"data-value\") || \"\");\n    selectedValues[optionIndex] = value;\n\n    // Handle split selection - clear selections from both standard and custom areas\n    if (optEl.classList.contains(\"pfd-split-option\")) {\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n      // Check if this swatch item is from the custom options area\n      const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n      if (!isFromCustomDropdown) {\n        // Reset custom dropdown to default state when selecting standard option\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        // Hide custom notice when standard option is selected\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    } else {\n      // Standard handling for non-split options\n      optEl\n        .querySelectorAll(\"[data-swatch-item].is--selected\")\n        .forEach((el) => el.classList?.remove(\"is--selected\"));\n    }\n\n    item.classList.add(\"is--selected\");\n\n    // Update current value display - handle both Color and Non-Color structures\n    const valueFromItem = item.getAttribute(\"data-value\") || \"\";\n    const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n    const displayValue = getDisplayValue(valueFromItem, optionUnit);\n\n    // Check if this is a custom option to add badge\n    const isFromCustomDropdown = item.closest(\".pfd-custom-options\");\n\n    let titleElement = optEl.querySelector(\".t4s-swatch__title--right .bold\");\n    if (titleElement) {\n      // Non-Color section structure\n      titleElement.textContent = displayValue;\n    } else {\n      // Color section structure - use the wrapper span\n      titleElement = optEl.querySelector(\".t4s-selected-value\");\n      if (titleElement) {\n        titleElement.textContent = displayValue;\n      }\n    }\n\n    // Update custom dropdown display for selected custom options\n    if (isFromCustomDropdown) {\n      const customDropdown = optEl.querySelector(\n        \".pfd-custom-dropdown [data-current-value]\",\n      );\n      if (customDropdown) {\n        customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n      }\n\n      // Show custom notice and update text\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery. Custom orders are non-cancellable/refundable.`;\n        }\n        customNotice.style.display = \"block\";\n      }\n    } else {\n      // Hide custom notice when standard option is selected\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      if (customNotice) {\n        customNotice.style.display = \"none\";\n      }\n    }\n\n    // resolve full variant and apply to select\n    const variantId = resolveVariantId(selectedValues);\n    if (variantId) {\n      // Update HTML data attributes with correct variant info before applying variant\n      const variant = window.__PFD\n        ? window.__PFD.variantById.get(variantId)\n        : null;\n      if (variant) {\n        const selectEl = item\n          .closest(\"form, .t4s-form__product\")\n          ?.querySelector('select[name=\"id\"]');\n        const selectedOption = selectEl?.querySelector(\n          `option[value=\"${variantId}\"]`,\n        );\n        if (selectedOption) {\n          // Update HTML data attributes that the theme actually checks\n          selectedOption.setAttribute(\n            \"data-incoming\",\n            variant.incoming || \"false\",\n          );\n          selectedOption.setAttribute(\n            \"data-nextincomingdate\",\n            variant.nextIncomingDate || \"\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventorypolicy\",\n            variant.inventoryPolicy || \"deny\",\n          );\n          selectedOption.setAttribute(\n            \"data-inventoryquantity\",\n            variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n          );\n        }\n      }\n\n      // Ensure DOM exists before applying variant\n      ensureDOMForVariant(variantId);\n      applyVariantToSelect(variantId);\n    }\n\n    // re-patch sold-out\n    patchAllAvailability();\n  }\n\n  // Make function available globally for our override\n  window.handlePFDSwatchClick = handlePFDSwatchClick;\n\n  // Setup split selection dropdown handlers\n  function setupSplitSelectionHandlers() {\n    document.addEventListener(\"click\", function (e) {\n      // Handle custom dropdown item selection\n      const dropdownItem = e.target.closest(\n        \"[data-swatch-item][data-dropdown-off]\",\n      );\n      if (dropdownItem && dropdownItem.closest(\".pfd-custom-options\")) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const value = dropdownItem.getAttribute(\"data-value\") || \"\";\n        const cleanedValue = getDisplayValue(value);\n\n        // Find the custom dropdown button\n        const dropdownWrapper = dropdownItem.closest(\".t4s-dropdown__wrapper\");\n        if (dropdownWrapper) {\n          const dropdownId = dropdownWrapper.id;\n          const customButton = document.querySelector(\n            `[data-pfd-dropdown-open][data-id=\"${dropdownId}\"]`,\n          );\n\n          if (customButton) {\n            // Update the dropdown button text to show the selected value\n            const currentValueSpan = customButton.querySelector(\n              \"[data-current-value]\",\n            );\n            if (currentValueSpan) {\n              // Get the option unit from the parent option element\n              const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n              const optionUnit = optionEl\n                ? optionEl.getAttribute(\"data-option-unit\") || \"\"\n                : \"\";\n\n              // Display the value with unit if available\n              const displayValue = optionUnit\n                ? `${cleanedValue} ${optionUnit}`\n                : cleanedValue;\n\n              currentValueSpan.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            // Close the dropdown\n            dropdownWrapper.classList.remove(\"is-open\");\n            customButton.setAttribute(\"aria-expanded\", \"false\");\n          }\n\n          // Show custom notice for dropdown selection and update text\n          const optionEl = dropdownItem.closest(\"[data-swatch-option]\");\n          const customNotice = optionEl\n            ? optionEl.querySelector(\".pfd-custom-notice\")\n            : null;\n          if (customNotice && optionEl) {\n            const optionName =\n              optionEl.getAttribute(\"data-option-name\") || \"item\";\n            const noticeText = customNotice.querySelector(\n              \".pfd-custom-notice-text\",\n            );\n            if (noticeText) {\n              noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n            }\n            customNotice.style.display = \"block\";\n          }\n\n          // Clear all selected states from the option group (both standard and custom)\n          if (optionEl && optionEl.classList.contains(\"pfd-split-option\")) {\n            optionEl\n              .querySelectorAll(\"[data-swatch-item].is--selected\")\n              .forEach((el) => el.classList?.remove(\"is--selected\"));\n\n            // Remove active state from ALL dropdown buttons in this option group\n            optionEl\n              .querySelectorAll(\".pfd-custom-dropdown\")\n              .forEach((btn) => btn.classList?.remove(\"is--selected\"));\n          }\n\n          // Add active state to THIS dropdown button\n          if (customButton) {\n            customButton.classList.add(\"is--selected\");\n          }\n        }\n\n        // Trigger the standard swatch selection logic\n        handleCustomSwatchClick(dropdownItem, e);\n        return;\n      }\n\n      // Handle custom dropdown clicks\n      const customDropdown = e.target.closest(\"[data-pfd-dropdown-open]\");\n      if (customDropdown) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const dropdownId = customDropdown.getAttribute(\"data-id\");\n        const dropdownWrapper = document.getElementById(dropdownId);\n\n        if (dropdownWrapper) {\n          const isOpen = dropdownWrapper.classList.contains(\"is-open\");\n\n          // Close all PFD dropdowns first\n          document\n            .querySelectorAll(\n              \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n            )\n            .forEach((wrapper) => wrapper.classList?.remove(\"is-open\"));\n\n          // Toggle current dropdown\n          if (!isOpen) {\n            dropdownWrapper.classList.add(\"is-open\");\n            customDropdown.setAttribute(\"aria-expanded\", \"true\");\n          } else {\n            customDropdown.setAttribute(\"aria-expanded\", \"false\");\n          }\n        }\n\n        return;\n      }\n\n      // Close dropdowns when clicking outside\n      if (\n        !e.target.closest(\".pfd-custom-options\") &&\n        !e.target.closest(\".t4s-dropdown__wrapper\")\n      ) {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n            }\n          });\n      }\n    });\n\n    // Handle keyboard navigation for dropdowns\n    document.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Escape\") {\n        document\n          .querySelectorAll(\n            \".pfd-custom-options .t4s-dropdown__wrapper.is-open\",\n          )\n          .forEach((wrapper) => {\n            wrapper.classList?.remove(\"is-open\");\n            const customButton = document.querySelector(\n              `[data-pfd-dropdown-open][data-id=\"${wrapper.id}\"]`,\n            );\n            if (customButton) {\n              customButton.setAttribute(\"aria-expanded\", \"false\");\n              customButton.focus();\n            }\n          });\n      }\n    });\n  }\n\n  // Initialize split selection handlers\n  setupSplitSelectionHandlers();\n\n  // ---------- Bootstrap selection ----------\n  const domSelected = getSelectedFromDOM();\n  for (let i = 0; i < optionCount; i++)\n    selectedValues[i] = domSelected[i] || \"\";\n  patchAllAvailability();\n\n  // Initial image update with any existing data\n  updateSwatchImages();\n  updateVariantImages();\n\n  // Show custom notice on page load if custom option is already selected\n  setTimeout(() => {\n    const swatchOptions = document.querySelectorAll(\"[data-swatch-option]\");\n    swatchOptions.forEach((optEl) => {\n      const selectedCustomItem = optEl.querySelector(\n        \".pfd-custom-options [data-swatch-item].is--selected\",\n      );\n      const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n      const customDropdownButton = optEl.querySelector(\".pfd-custom-dropdown\");\n\n      if (selectedCustomItem && customNotice) {\n        const optionName = optEl.getAttribute(\"data-option-name\") || \"item\";\n        const noticeText = customNotice.querySelector(\n          \".pfd-custom-notice-text\",\n        );\n        if (noticeText) {\n          noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n        }\n        customNotice.style.display = \"block\";\n\n        // Add active state to dropdown button if custom option is selected\n        if (customDropdownButton) {\n          customDropdownButton.classList.add(\"is--selected\");\n        }\n      }\n    });\n  }, 100);\n\n  // Initial thumbnail update on page load\n  if (typeof $ !== \"undefined\") {\n    setTimeout(() => {\n      triggerThumbnailUpdate();\n    }, 500);\n  }\n\n  // ---------- Storefront hydration ----------\n  const productHandle = window.__PRODUCT_HANDLE__;\n  if (!productHandle) {\n    console.warn(\"[PFD] Missing window.__PRODUCT_HANDLE__\");\n    return;\n  }\n\n  const endpoint = `${window.location.origin}/api/2026-01/graphql.json`;\n\n  function sfFetch(query, variables, fallback = false) {\n    const headers = {\n      \"content-type\": \"application/json\",\n    };\n\n    if (!fallback) {\n      headers[\"X-Shopify-Storefront-Access-Token\"] =\n        \"5b053b572b0031f80b6d0465d5be4a18\";\n    }\n\n    return fetch(endpoint, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({ query, variables }),\n    }).then((r) => r.json());\n  }\n\n  async function hydrateAllVariants(fallback = false) {\n    const variantImageField = fallback\n      ? \"\"\n      : `\n      variant_image: metafield(key: \"variant_image\", namespace: \"custom\") {\n        references(first: 5) {\n          nodes {\n            ... on MediaImage {\n              id\n              image {\n                url\n              }\n            }\n          }\n        }\n      }\n    `;\n\n    const quantityAvailableField = fallback ? \"\" : \"quantityAvailable\";\n\n    const query = `\n      query VariantsPage($handle: String!, $first: Int!, $after: String) {\n        product(handle: $handle) {\n          requiresSellingPlan\n          variants(first: $first, after: $after) {\n            pageInfo { hasNextPage endCursor }\n            nodes {\n              id\n              title\n              availableForSale\n              selectedOptions { name value }\n              sku\n              taxable\n              price {\n                amount\n              }\n              compareAtPrice {\n                amount\n              }\n              weight\n              barcode\n              ${quantityAvailableField}\n              image {\n                id\n                url\n                width\n                height\n                altText\n              }\n              ${variantImageField}\n            }\n          }\n        }\n      }\n    `;\n\n    let after = null;\n    while (true) {\n      const res = await sfFetch(\n        query,\n        {\n          handle: productHandle,\n          first: 250,\n          after,\n        },\n        fallback,\n      );\n\n      if (res?.data?.product === null && !fallback) {\n        return hydrateAllVariants(true);\n      }\n\n      const nodes = res?.data?.product?.variants?.nodes || [];\n      const pageInfo = res?.data?.product?.variants?.pageInfo;\n      const productRequiresSellingPlan =\n        res?.data?.product?.requiresSellingPlan || false;\n\n      for (const n of nodes) {\n        const gid = String(n.id);\n        const numericId = gid.includes(\"/\") ? gid.split(\"/\").pop() : gid;\n\n        const optMap = new Map(\n          (n.selectedOptions || []).map((o) => [\n            normName(o.name),\n            normVal(o.value),\n          ]),\n        );\n\n        // Extract variant images - collect all images from variant_image metafield\n        const variantImageNodes = n.variant_image?.references?.nodes || [];\n        const variantImages = variantImageNodes\n          .map((node) => node.image?.url)\n          .filter(Boolean);\n        const mainImageUrl = n.image?.url;\n        const imageUrl = mainImageUrl;\n\n        // Build featured_image object to match theme format\n        const featuredImage = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              src: n.image.url,\n              width: n.image.width || 600,\n              height: n.image.height || 600,\n              alt: n.image.altText || null,\n            }\n          : null;\n\n        // Build featured_media object to match theme format\n        const featuredMedia = n.image\n          ? {\n              id: n.image.id\n                ? String(n.image.id).includes(\"/\")\n                  ? String(n.image.id).split(\"/\").pop()\n                  : n.image.id\n                : null,\n              alt: n.image.altText || null,\n              preview_image: {\n                aspect_ratio:\n                  n.image.width && n.image.height\n                    ? n.image.width / n.image.height\n                    : 1,\n                height: n.image.height || 600,\n                width: n.image.width || 600,\n                src: n.image.url,\n              },\n            }\n          : null;\n\n        // Get option values for title and public_title\n        const optionValues = (n.selectedOptions || []).map((o) => o.value);\n\n        const rawVariant = {\n          id: numericId,\n          title: n.title,\n          available: !!n.availableForSale,\n          sku: n.sku,\n          requires_shipping: true,\n          taxable: n.taxable !== false,\n          featured_image: featuredImage,\n          options: optionValues,\n          price: n.price ? Math.round(parseFloat(n.price.amount) * 100) : 0,\n          weight: n.weight || 0,\n          compare_at_price: n.compareAtPrice\n            ? Math.round(parseFloat(n.compareAtPrice.amount) * 100)\n            : null,\n          inventory_management: \"shopify\",\n          barcode: n.barcode || \"\",\n          featured_media: featuredMedia,\n          inventory_policy: null,\n          inventory_quantity:\n            n.quantityAvailable !== undefined ? n.quantityAvailable : 0,\n          imageUrl: imageUrl,\n          variantImages:\n            variantImages.length > 0\n              ? variantImages\n              : mainImageUrl\n                ? [mainImageUrl]\n                : [],\n        };\n\n        for (let i = 0; i < optionCount; i++) {\n          const optName = normName(options?.[i]?.name);\n          rawVariant[`option${i + 1}`] = optName\n            ? optMap.get(optName) || \"\"\n            : \"\";\n        }\n\n        const v = buildThemeVariant(rawVariant, productRequiresSellingPlan);\n\n        // Store the product selling plan info for upsertVariant\n        v._productRequiresSellingPlan = productRequiresSellingPlan;\n\n        upsertVariant(v);\n\n        // Ensure option exists in select for hydrated variants\n        ensureSelectOption(numericId, v);\n      }\n\n      // Patch as data arrives (won't disable everything if partial)\n      patchAllAvailability();\n\n      if (!pageInfo?.hasNextPage) break;\n      after = pageInfo.endCursor;\n    }\n\n    // Final pass once all data is in\n    patchAllAvailability();\n\n    // Update swatch images with the loaded data\n    updateSwatchImages();\n\n    // Update variant images sections with the loaded data\n    updateVariantImages();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  function setDefaultVariant() {\n    console.log(\"[PFD] Selected Variant\", window.__HAS_SELECTED__);\n    console.log(\"[PFD] Default Variant\", window.__DEFAULT_VARIANT__);\n\n    // If there is a selected variant, do nothing (handled by server)\n    if (window.__HAS_SELECTED__) {\n      console.log(\n        \"[PFD] Selected variant exists, skipping default variant logic\",\n      );\n      return;\n    }\n\n    // If there is no selected variant, set the default variant\n    const defaultVariant = window.__DEFAULT_VARIANT__;\n    if (!defaultVariant || !defaultVariant.id) {\n      console.log(\"[PFD] No default variant specified\");\n      return;\n    }\n\n    console.log(\"[PFD] Setting default variant:\", defaultVariant.id);\n\n    // Get the variant from our data\n    const variant = variantById.get(String(defaultVariant.id));\n    console.log(\"variant\", { ...variant });\n    if (!variant) {\n      console.log(\"[PFD] Variant not found in cache:\", defaultVariant.id);\n      return;\n    }\n\n    // Step 1: Update selectedValues array (critical for system to work)\n    for (let i = 0; i < optionCount; i++) {\n      selectedValues[i] = variant[`option${i + 1}`] || \"\";\n    }\n\n    // Step 2: Clear all current visual selections\n    document\n      .querySelectorAll(\"[data-swatch-item].is--selected\")\n      .forEach((el) => {\n        el.classList.remove(\"is--selected\");\n      });\n\n    // Step 3: Update visual state for each option (exactly like click handler)\n    for (let i = 0; i < optionCount; i++) {\n      const optionValue = variant[`option${i + 1}`];\n      if (!optionValue) continue;\n\n      const optEl = document.querySelector(\n        `[data-swatch-option][data-id=\"${i}\"]`,\n      );\n      if (!optEl) continue;\n\n      const swatchItem = optEl.querySelector(\n        `[data-swatch-item][data-value=\"${optionValue.replace(/\"/g, '\\\\\"')}\"]`,\n      );\n      console.log(swatchItem);\n\n      // Check if this is a split option (has both standard and custom dropdown)\n      const isSplitOption = optEl.classList.contains(\"pfd-split-option\");\n\n      if (swatchItem) {\n        swatchItem.classList.add(\"is--selected\");\n\n        // Update display value exactly like click handler\n        const optionUnit = optEl.getAttribute(\"data-option-unit\") || \"\";\n        const displayValue = getDisplayValue(optionValue, optionUnit);\n\n        let titleElement = optEl.querySelector(\n          \".t4s-swatch__title--right .bold\",\n        );\n        if (titleElement) {\n          titleElement.textContent = displayValue;\n        } else {\n          titleElement = optEl.querySelector(\".t4s-selected-value\");\n          if (titleElement) {\n            titleElement.textContent = displayValue;\n          }\n        }\n\n        // Handle dropdown logic for split options\n        if (isSplitOption) {\n          const isFromCustomDropdown = swatchItem.closest(\n            \".pfd-custom-options\",\n          );\n\n          if (isFromCustomDropdown) {\n            // Custom option selected - update dropdown button and show custom notice\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              customDropdown.innerHTML = `${displayValue} <span class=\"pfd-custom-badge\">Custom</span>`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.add(\"is--selected\");\n            }\n\n            // Show custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              const optionName =\n                optEl.getAttribute(\"data-option-name\") || \"item\";\n              const noticeText = customNotice.querySelector(\n                \".pfd-custom-notice-text\",\n              );\n              if (noticeText) {\n                noticeText.innerHTML = `Custom ${optionName.toLowerCase()}s are <strong>made to order</strong>. Please allow <span class=\"pfd-custom-notice-highlight\">6-8 weeks</span> for delivery.`;\n              }\n              customNotice.style.display = \"block\";\n            }\n          } else {\n            // Standard option selected - reset dropdown to default state\n            const customDropdown = optEl.querySelector(\n              \".pfd-custom-dropdown [data-current-value]\",\n            );\n            const customDropdownButton = optEl.querySelector(\n              \".pfd-custom-dropdown\",\n            );\n\n            if (customDropdown) {\n              const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n              customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n            }\n\n            if (customDropdownButton) {\n              customDropdownButton.classList.remove(\"is--selected\");\n            }\n\n            // Hide custom notice\n            const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n            if (customNotice) {\n              customNotice.style.display = \"none\";\n            }\n          }\n        }\n      } else if (isSplitOption) {\n        // No matching swatch item found, but this is a split option\n        // Reset dropdown to default state since selection is not in standard or custom options\n        const customDropdown = optEl.querySelector(\n          \".pfd-custom-dropdown [data-current-value]\",\n        );\n        const customDropdownButton = optEl.querySelector(\n          \".pfd-custom-dropdown\",\n        );\n\n        if (customDropdown) {\n          const optionName = optEl.getAttribute(\"data-option-name\") || \"\";\n          customDropdown.textContent = `Custom ${optionName.toLowerCase()}`;\n        }\n\n        if (customDropdownButton) {\n          customDropdownButton.classList.remove(\"is--selected\");\n        }\n\n        // Hide custom notice\n        const customNotice = optEl.querySelector(\".pfd-custom-notice\");\n        if (customNotice) {\n          customNotice.style.display = \"none\";\n        }\n      }\n    }\n\n    // Step 4: Update HTML data attributes on select option (like click handler does)\n    const selectedOption = selectEl?.querySelector(\n      `option[value=\"${defaultVariant.id}\"]`,\n    );\n    if (selectedOption) {\n      selectedOption.setAttribute(\"data-incoming\", variant.incoming || \"false\");\n      selectedOption.setAttribute(\n        \"data-nextincomingdate\",\n        variant.nextIncomingDate || \"\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventorypolicy\",\n        variant.inventoryPolicy || \"deny\",\n      );\n      selectedOption.setAttribute(\n        \"data-inventoryquantity\",\n        variant.inventoryQuantity || (variant.available ? \"999\" : \"0\"),\n      );\n    }\n\n    // Step 5: Ensure DOM exists for variant\n    ensureDOMForVariant(defaultVariant.id);\n\n    // Step 6: Apply to select element\n    applyVariantToSelect(defaultVariant.id);\n\n    // Step 7: Re-patch availability (exactly like click handler)\n    patchAllAvailability();\n\n    // Update thumbnails after hydration completes\n    if (typeof $ !== \"undefined\") {\n      setTimeout(() => {\n        triggerThumbnailUpdate();\n      }, 200);\n    }\n  }\n\n  hydrateAllVariants(false)\n    .then(() => {\n      setDefaultVariant();\n    })\n    .catch((e) => console.warn(\"[PFD] Hydration failed\", e));\n})();\n",
              "reasoning": "Close the updateAvailableLengths function body — the closing brace was missing, causing the unclosed brace lint error at end of file."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          },
          {
            "name": "edit_lines",
            "id": "toolu_01HJ8t1ufCG59MJbsgNgAy6v",
            "input": {
              "filePath": "assets/product-form-dynamic.js",
              "startLine": 832,
              "endLine": 832,
              "newContent": "  }\n}\n",
              "reasoning": "Close the updateAvailableLengths function body — the closing brace was missing, causing the unclosed brace lint error at end of file."
            },
            "result": "(no result received)",
            "isError": true,
            "elapsedMs": 0
          }
        ],
        "reasoningBlocks": [],
        "responseText": "",
        "outcome": {
          "status": "applied",
          "changedFiles": 4,
          "changeSummary": "product-form-dynamic.css: Fix CSS for available lengths text: allow text wrapping (white-space: normal), strengthen the btn-wrap column layout override withimportant and add .pfd-has-lengths class selector for browsers without :has() support\nproduct-form-dynamic.js: Add pfd-has-lengths class to btn-wrap when lengths text is visible, and remove it when hidden. This ensures the column flex layout works in all browsers without relying solely on :has().",
          "validationIssues": [
            {
              "gate": "theme_check",
              "errors": [
                "templates/page.ecom-deadfest2025.json — Invalid JSON in template file",
                "templates/article.portfolio.json — Invalid JSON in template file",
                "templates/page.ecom-deaducation-live-phoenix.json — Invalid JSON in template file",
                "templates/index.ecom-preview-home.json — Invalid JSON in template file",
                "templates/index.ecom-preview-page.json — Invalid JSON in template file"
              ],
              "changesKept": true
            }
          ]
        },
        "metrics": {
          "totalToolCalls": 27,
          "editToolCalls": 8,
          "readToolCalls": 16,
          "searchToolCalls": 1,
          "elapsedMs": 239470,
          "costCents": 45,
          "inputTokens": 111387,
          "outputTokens": 7428
        }
      },
      "analysis": {
        "diagnosis": {
          "summary": "Agent successfully completed the task (4 files changed) but encountered 10 tool execution errors (calls 17-27) during the process. The errors occurred in semantic_search, extract_region, and multiple edit_lines/propose_code_edit calls, yet the agent recovered and applied changes. The actual outcome indicates changes were made despite error states, suggesting either error recovery logic masked failures or tool executor silently succeeded after logging errors.",
          "rootCause": "Tool executor error handling is inconsistent. Calls 17-27 show [ERROR] states with 'no result received' messages, but the final outcome shows 4 files were changed. This indicates: (1) Tool definitions or executor is returning error states incorrectly, (2) Error messages are logged but execution continues, or (3) Tool input validation is failing before execution but subsequent retries succeed silently. The coordinator did not halt or escalate these errors, suggesting validation gates in orchestration-policy are either not triggered or not enforced for tool execution failures.",
          "agentBehavior": "Agent followed GOD_MODE strategy with Sonnet-4-6 model (appropriate for COMPLEX tier). It performed 16 read operations to understand the codebase, then attempted 8 edits with multiple errors. Despite error logging, the agent did not: (1) explicitly acknowledge or handle errors in reasoning, (2) request second opinion or review, (3) adjust strategy or fallback to simpler approach. The agent appears to have continued iterating through errors without stagnation detection triggering. Token usage (111k in / 7.4k out) suggests the agent consumed context but produced minimal reasoning output, indicating either reasoning was not captured or agent was operating in low-verbosity mode."
        },
        "recommendations": [
          {
            "priority": "critical",
            "category": "tools",
            "title": "Fix tool executor error handling and result propagation",
            "description": "Tool executor (v2-tool-executor.ts) is returning error states but not properly propagating failure information to coordinator. Calls 17-27 show [ERROR] with 'no result received' but changes were applied anyway. Need to: (1) Ensure tool_use blocks properly return error objects with error field, (2) Validate that tool input JSON is well-formed before execution, (3) Return consistent error structure for all tool failures, (4) Ensure coordinator can distinguish between 'tool failed' vs 'tool succeeded with warnings'.",
            "targetFile": "lib/agents/tools/v2-tool-executor.ts",
            "targetArea": "Error handling in run_specialist, run_review execution paths and result validation",
            "suggestedChange": "Add try-catch wrapper around tool execution with explicit error object return: { error: string, code: string, tool: string, input: object }. Validate JSON parsing before tool invocation. Ensure all error paths return structured errors instead of letting exceptions propagate. Add logging of tool success/failure status to coordinator context."
          },
          {
            "priority": "critical",
            "category": "coordinator",
            "title": "Implement tool failure detection and recovery in main loop",
            "description": "Coordinator (coordinator-v2.ts) does not appear to detect or handle tool execution errors. When tools return error states (calls 17-27), coordinator should: (1) Detect error field in tool result, (2) Log error with severity, (3) Decide whether to retry, escalate, or adjust strategy, (4) Trigger validation gate or request second opinion if error rate exceeds threshold. Currently coordinator continues iterating without acknowledging errors.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Main think-tool-observe loop, tool result processing after tool executor returns",
            "suggestedChange": "After tool execution, check result for error field. If present: increment error counter, log with context, evaluate error type (validation vs execution vs timeout). If error_count > threshold or error is critical, invoke validation gate or trigger run_review. Add error state to context passed to next PM iteration so agent is aware of failures."
          },
          {
            "priority": "high",
            "category": "validation",
            "title": "Add validation gate for tool input before execution",
            "description": "Calls 19 and 20 show 'Failed to parse tool input JSON' errors. Tool definitions or coordinator is generating malformed JSON for tool calls. Orchestration policy validation gates should catch this before tool executor receives the call. Need stricter schema validation against tool_definitions.",
            "targetFile": "lib/agents/orchestration-policy.ts",
            "targetArea": "Validation gates section, pre-execution tool input validation",
            "suggestedChange": "Add validateToolInput(toolName, input, schema) gate that: (1) Checks required fields against tool definition schema, (2) Validates field types and formats, (3) Returns validation error with specific field path if invalid, (4) Prevents tool executor from being called with malformed input. Gate should run before tool executor and report errors back to coordinator for retry or escalation."
          },
          {
            "priority": "high",
            "category": "prompt",
            "title": "Enhance PM prompt with error recovery instructions",
            "description": "PM prompt (v2-pm-prompt.ts) does not include explicit instructions for handling tool failures. When agent encounters tool errors, it should have clear guidance on: (1) How to recognize error states, (2) When to retry vs escalate, (3) How to request second opinion, (4) How to adjust strategy if tools are failing. Current prompt assumes tools always succeed.",
            "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
            "targetArea": "Tool usage section and error handling guidance",
            "suggestedChange": "Add section: 'If a tool returns an error result (contains error field), stop and analyze: Is the error due to malformed input (retry with corrected JSON) or tool unavailability (escalate via run_review)? If error persists after 2 retries, request second opinion or simplify strategy. Always acknowledge errors in reasoning before continuing.'"
          },
          {
            "priority": "high",
            "category": "coordinator",
            "title": "Add stagnation detection for error loops",
            "description": "Calls 17-27 show 10 consecutive errors with minimal recovery. Coordinator should detect when agent is stuck in error loop (same tool failing repeatedly or error rate > 30%) and trigger intervention: switch strategy, reduce scope, or escalate to human review.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Iteration loop, stagnation detection logic",
            "suggestedChange": "Track error_count and error_types per iteration. If error_count > 3 in last 5 iterations OR same tool fails 3+ times consecutively, trigger stagnation protocol: (1) Log stagnation alert, (2) Reduce context window or scope, (3) Switch to SIMPLE strategy if currently HYBRID/GOD_MODE, (4) Escalate to run_review or human if still stagnating after strategy change."
          },
          {
            "priority": "medium",
            "category": "tools",
            "title": "Fix semantic_search and extract_region tool definitions",
            "description": "Calls 17 and 18 show semantic_search and extract_region returning no results. These tools may be missing from tool executor or have incorrect input schemas. Need to verify: (1) Tool is registered in tool executor, (2) Input format matches schema, (3) Tool is actually callable in current environment.",
            "targetFile": "lib/agents/tools/v2-tool-definitions.ts",
            "targetArea": "semantic_search and extract_region tool definitions",
            "suggestedChange": "Verify semantic_search and extract_region are defined with correct input schemas. If these tools are not implemented, remove from tool definitions and update PM prompt to not suggest them. If implemented, add detailed input examples and error cases to schema."
          },
          {
            "priority": "medium",
            "category": "context",
            "title": "Capture and preserve agent reasoning in error states",
            "description": "Transcript shows '(no reasoning captured)' for last 5 blocks. Agent reasoning is not being persisted when errors occur. This makes debugging impossible and prevents coordinator from learning from failures.",
            "targetFile": "lib/agents/coordinator-v2.ts",
            "targetArea": "Reasoning capture and context building, especially around error handling",
            "suggestedChange": "Ensure PM reasoning is captured and stored in context even when tool errors occur. Add explicit reasoning step after errors: 'What went wrong? How should I recover?' Store this in transcript so coordinator can review and adjust strategy."
          },
          {
            "priority": "medium",
            "category": "strategy",
            "title": "Reconsider GOD_MODE strategy for file editing tasks",
            "description": "Agent selected GOD_MODE for COMPLEX tier, which may have increased tool complexity and error surface. For CSS/JS editing with clear target files, HYBRID or SIMPLE might be more reliable.",
            "targetFile": "lib/agents/strategy.ts",
            "targetArea": "Strategy selection logic for COMPLEX tier",
            "suggestedChange": "Adjust strategy selection: if request is 'file editing' or 'CSS/JS changes' with clear file targets (identified by scout), prefer HYBRID over GOD_MODE. Reserve GOD_MODE for truly open-ended exploration tasks. This reduces tool complexity and error risk."
          }
        ]
      }
    }
  ],
  "summary": {
    "passRate": "0/1 (0%)",
    "avgToolCalls": 27,
    "avgTimeSeconds": 239,
    "totalCostCents": 45,
    "failureReasons": [
      "Too many tool calls (27/25) — looping"
    ]
  },
  "aggregateAnalysis": {
    "diagnosis": {
      "summary": "Single successful run with high tool usage (27 tools, 239s) and multiple non-fatal errors that did not prevent task completion. The agent successfully applied changes to 4 files despite encountering 11 errors across semantic_search, extract_region, read_lines, propose_code_edit, and edit_lines operations.",
      "rootCause": "Tool execution resilience: The agent continued iterating despite receiving no results or errors from intermediate tools, suggesting either: (1) errors were caught and retried internally, (2) the PM prompt's error handling instructed the agent to proceed with fallback logic, or (3) tool failures were non-blocking by design. With only 1 run available, the root cause of error tolerance cannot be definitively attributed to prompt design, tool executor logic, or coordinator retry policy.",
      "agentBehavior": "The agent exhibited persistence and adaptive tool selection. After encountering semantic_search and extract_region failures, it pivoted to read_lines operations (13 consecutive reads) to manually locate target code. It then alternated between propose_code_edit and edit_lines (4 cycles) to apply changes iteratively. This suggests the PM prompt contains fallback instructions or the coordinator implements automatic retry/pivot logic."
    },
    "patterns": {
      "consistentFailureMode": null,
      "intermittentIssues": [
        "semantic_search returned no result — may indicate search term mismatch or theme map gap",
        "extract_region returned no result — suggests target region not found or malformed query",
        "read_lines returned no result — unusual; may indicate file path error or coordinator context loss",
        "propose_code_edit returned no result — suggests code edit proposal was rejected or malformed",
        "edit_lines returned no result — suggests edit application failed silently or edit was invalid"
      ],
      "toolUsageAntiPatterns": [
        "13 consecutive read_lines calls suggest inefficient file scanning; scout brief or theme map lookup may not have provided accurate line ranges",
        "4 cycles of propose_code_edit → edit_lines suggests iterative refinement; unclear if this was intentional or caused by repeated edit failures",
        "semantic_search followed immediately by extract_region and then manual read_lines suggests search-based targeting failed and agent fell back to linear scanning"
      ],
      "contextGaps": [
        "No evidence of scout brief usage before read_lines calls; structural-scout may not have been invoked or provided insufficient targeting",
        "Theme map lookup may not have indexed all 4 modified files or provided stale line ranges",
        "No grep_content usage despite multiple file reads; agent did not leverage grep for cross-file pattern matching"
      ]
    },
    "recommendations": [
      {
        "priority": "critical",
        "category": "coordinator",
        "title": "Add error tracking and retry policy for non-fatal tool failures",
        "description": "The agent encountered 11 errors but continued to completion. Implement explicit retry logic in coordinator-v2.ts for tool failures: (1) classify error severity (transient vs. permanent), (2) retry with backoff for transient errors, (3) log retry attempts for debugging, (4) escalate after N retries to prevent infinite loops.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Main loop error handling (after tool execution)",
        "suggestedChange": "Add toolRetryPolicy with max_retries=3, backoff_ms=500. Wrap tool executor calls in try-catch with retry wrapper. Log all retries to context for PM visibility."
      },
      {
        "priority": "high",
        "category": "context",
        "title": "Validate scout brief and theme map output before tool execution",
        "description": "13 consecutive read_lines calls indicate scout brief or theme map failed to provide accurate file targeting. Add validation gates in coordinator-v2.ts: (1) check if scout brief was generated and non-empty, (2) verify theme map returned line ranges for all target files, (3) if validation fails, trigger re-scout or fallback to grep-based targeting.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Context building phase, after scout brief generation",
        "suggestedChange": "Add orchestration-policy gate: if (scout_brief.files.length === 0 || theme_map.lookup_failures > 0) { trigger_rescan() }. Log scout brief and theme map results for debugging."
      },
      {
        "priority": "high",
        "category": "prompt",
        "title": "Add explicit fallback instructions for semantic_search and extract_region failures",
        "description": "When semantic_search returns no results, the agent should pivot to grep_content or structured read_lines. When extract_region fails, agent should use read_lines with explicit line ranges from theme map. Add these fallback strategies to v2-pm-prompt.ts to make pivoting deterministic and logged.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Tool usage instructions section",
        "suggestedChange": "Add fallback instruction block: 'If semantic_search returns no results, use grep_content with broader patterns. If extract_region fails, use read_lines with line ranges from the theme map. Log all fallbacks in your thinking.'"
      },
      {
        "priority": "high",
        "category": "tools",
        "title": "Enhance semantic_search and extract_region error messages",
        "description": "semantic_search and extract_region returned no results without error details. Modify v2-tool-executor.ts to return structured error responses: (1) why the search/extraction failed (pattern not found, region out of bounds, etc.), (2) suggested fallback (grep_content, manual read_lines with line range), (3) context snippet for debugging.",
        "targetFile": "lib/agents/tools/v2-tool-executor.ts",
        "targetArea": "semantic_search and extract_region execution handlers",
        "suggestedChange": "Return { success: false, reason: 'pattern_not_found', fallback: 'use_grep_content', context: 'searched_in_file_X_lines_Y_to_Z' } instead of silent no-result responses."
      },
      {
        "priority": "high",
        "category": "context",
        "title": "Implement theme map pre-validation for all target files",
        "description": "Before PM begins tool execution, verify theme map has indexed all files mentioned in the task. Run structural-scout with LLM brief enabled to identify all relevant files. Cache results and pass to PM in initial context.",
        "targetFile": "lib/agents/theme-map/cache.ts",
        "targetArea": "Cache initialization and lookup validation",
        "suggestedChange": "Add pre_validation() method: for each file in scout_brief, call theme_map.lookup() and verify line ranges are non-empty. If lookup fails, trigger re-scan. Return validation_report to coordinator."
      },
      {
        "priority": "medium",
        "category": "coordinator",
        "title": "Add stagnation detection for repeated tool failures",
        "description": "If the same tool fails 3+ times in a row, or if agent reads the same file 3+ times without editing, trigger strategy escalation (SIMPLE → HYBRID → GOD_MODE) or request human intervention.",
        "targetFile": "lib/agents/coordinator-v2.ts",
        "targetArea": "Iteration loop, after tool execution",
        "suggestedChange": "Track tool_failure_streak and file_read_count per file. If streak >= 3 or read_count >= 3, call escalateStrategy() or halt with diagnostic report."
      },
      {
        "priority": "medium",
        "category": "prompt",
        "title": "Add explicit tool sequencing guidance to reduce redundant operations",
        "description": "The agent used semantic_search then extract_region then read_lines sequentially. Add guidance to v2-pm-prompt.ts: (1) prefer grep_content for pattern matching before semantic_search, (2) use theme map line ranges to target read_lines precisely, (3) avoid reading the same file region twice.",
        "targetFile": "lib/agents/prompts/v2-pm-prompt.ts",
        "targetArea": "Tool selection strategy section",
        "suggestedChange": "Add ordering: 'Prefer: (1) grep_content for broad pattern matching, (2) theme_map lookup for line ranges, (3) read_lines with specific ranges, (4) semantic_search only if semantic understanding is required. Never read the same file region twice in succession.'"
      },
      {
        "priority": "medium",
        "category": "validation",
        "title": "Add post-edit validation to confirm changes were applied",
        "description": "The agent called propose_code_edit and edit_lines multiple times (4 cycles). Add validation after each edit_lines call: (1) re-read the edited lines to confirm change, (2) run check_lint to verify syntax, (3) log before/after diff for debugging.",
        "targetFile": "lib/agents/orchestration-policy.ts",
        "targetArea": "Post-edit validation gate",
        "suggestedChange": "Add policy: after edit_lines, always call read_lines to confirm change. If read result differs from proposed change, log mismatch and retry with clearer edit instruction."
      },
      {
        "priority": "low",
        "category": "strategy",
        "title": "Consider HYBRID strategy for multi-file changes",
        "description": "This run modified 4 files and used 27 tools. For complex multi-file scenarios, HYBRID strategy (with run_specialist for parallel file analysis) may reduce total tool calls and iteration time.",
        "targetFile": "lib/agents/strategy.ts",
        "targetArea": "Strategy selection logic",
        "suggestedChange": "If task involves 3+ files, prefer HYBRID over SIMPLE. Trigger run_specialist for file-level analysis in parallel."
      }
    ]
  }
}